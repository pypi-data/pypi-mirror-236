# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['classy_fastapi']

package_data = \
{'': ['*']}

install_requires = \
['fastapi>=0.73.0,<1.0.0', 'pydantic>=1.10.2,<3.0.0']

setup_kwargs = {
    'name': 'classy-fastapi',
    'version': '0.6.1',
    'description': 'Class based routing for FastAPI',
    'long_description': '# Overview\n\nThis project contains classes and decorators to use FastAPI with "class based routing". In particular this allows you to\nconstruct an **instance** of a class and have methods of that instance be route handlers. For example:\n\n```py\nfrom dao import Dao\n# Some fictional dao\nfrom classy_fastapi import Routable, get, delete\n\ndef parse_arg() -> argparse.Namespace:\n   """parse command line arguments."""\n   ...\n\n\nclass UserRoutes(Routable):\n   """Inherits from Routable."""\n\n   # Note injection here by simply passing values to the constructor. Other injection frameworks also\n   # supported as there\'s nothing special about this __init__ method.\n   def __init__(self, dao: Dao) -> None:\n      """Constructor. The Dao is injected here."""\n      super().__init__()\n      self.__dao = Dao\n\n   @get(\'/user/{name}\')\n   def get_user_by_name(self, name: str) -> User:\n      # Use our injected DAO instance.\n      return self.__dao.get_user_by_name(name)\n\n   @delete(\'/user/{name}\')\n   def delete_user(self, name: str) -> None:\n      self.__dao.delete(name)\n\n\ndef main():\n    args = parse_args()\n    # Configure the DAO per command line arguments\n    dao = Dao(args.url, args.user, args.password)\n    # Simple intuitive injection\n    user_routes = UserRoutes(dao)\n\n    app = FastAPI()\n    # router member inherited from cr.Routable and configured per the annotations.\n    app.include_router(user_routes.router)\n```\n\nNote that there are no global variables and dependency injection is accomplished by simply passing arguments to the\nconstructor.\n\n# Why\n\nFastAPI generally has one define routes like:\n\n```py\napp = FastAPI()\n\n@app.get(\'/echo/{x}\')\ndef echo(x: int) -> int:\n   return x\n```\n\nNote that `app` is a global. Furthermore, [FastAPI\'s suggested way of doing dependency\ninjection](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/) is handy for things like pulling\nvalues out of header in the HTTP request. However, they don\'t work well for more standard dependency injection scenarios\nwhere we\'d like to do something like inject a DAO or database connection. For that, FastAPI suggests [their\nparameterized dependencies](https://fastapi.tiangolo.com/advanced/advanced-dependencies/) which might look something\nlike:\n\n```py\napp = FastAPI()\n\nclass ValueToInject:\n   def __init__(self, y: int) -> None:\n      self.y = y\n\n   def __call__(self) -> int:\n      return self.y\n\nto_add = ValueToInject(2)\n\n@app.get(\'/add/{x}\')\ndef add(x: int, y: Depends(to_add)) -> int:\n   return x + y\n```\n\nThis works but there\'s a few issues:\n\n* The `Dependency` must be a callable which requires an unfortunate amount of boilerplate.\n* If we want to use the same dependency on several routes, as we would with something like a database connection, we\n  have to repeat the `Dependency(to_add)` bit on each endpoint. Note that FastAPI lets you group endpoints your we can\n  [include the dependency on all of them]( https://fastapi.tiangolo.com/tutorial/bigger-applications) but then there\'s\n  no way to access the dependency from the router code so this really only works for things like authentication where\n  the dependency can do some route handling (e.g. return a 402 if an auth header is missing).\n* `to_add` is a global variable which is limiting.\n\nLet\'s consider an expanded, more realistic example where we have a group of routes that operate on users to add them,\ndelete them, change the password, etc. Those routes will need to access a database so we have a DAO that helps set that\nup. We\'re going to take the database URL, password, etc. via command line arguments and then set up our routes.\nFurthermore, we\'ll split up our application into a few separate files. Doing this without class routing looks like the\nfollowing:\n\n```py\n# main.py\n\nimport .user\nfrom .deps import dao\n\ndef parse_arg() -> argparse.Namespace:\n   """parse command line arguments."""\n   ...\n\ndef main():\n    args = parse_args()\n    global dao\n    dao = Dao(args.url, args.user, args.password)\n\n    app = FastAPI()\n    app.include_router(user.router)\n\n####\n# dao.py\n\nfrom dao import Dao\n\n# DAO for injection. We don\'t know the command line arguments yet but we need to make this global as we need to be able\n# to access it in user.py below so it\'s None here and gets set in main()\ndao: Optional[Dao] = None\n\n#####\n# user.py\nfrom .deps import dao\nfrom dao import Dao\nfrom fastapi.routing import APIRouter\n\n@router.get(\'/user/{name}\')\ndef get_user_by_name(name: str, dao: Dao = Depends(dao)) -> User:\n   return dao.get_user_by_name(name)\n\n@router.delete(\'/user/{name}\')\ndef delete_user(name: str, dao: Dao = Depends(dao)) -> None:\n   dao.delete(name)\n\n# ... additional user methods ...\n```\n\nThat works but it\'s a bit verbose. Additionally, as noted above, it has some limitations. For example, suppose we\'ve\nupdated our API in a breaking way so we\'ve added a `/v2` set of routes. However, the `users.py` routes haven\'t changed\nat all except that we\'ve changed how we store users (e.g. a new password hashing algorithm) so `/v2` user routes need to\nuse a different DAO. Ideally you\'d call `app.include_router` twice with different prefixes but that won\'t work because\nthe dependency on the DAO is to _a specific DAO instance_ in `user.py`. You can add [dependency\noverrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/) but it feels awkward.\n\nBy contrast the class based routing in this package does not have any global variables at all and injection can be\nperformed by simply passing values to a constructor or via any other dependency injection framework.\n\n## Alternatives\n\n[FastAPI-utils](https://fastapi-utils.davidmontague.xyz/user-guide/class-based-views/) has a class based views\nimplementation but the routes are on the class itself rather than on **instances** of the class.\n\nThere\'s demand for this feature so a number of alternatives have been proposed [in an open\nbug](https://github.com/tiangolo/fastapi/issues/270) and [on\nStackOverflow](https://stackoverflow.com/q/63853813/1431244) but all seem to require global injection or hacks like\ndefining all the routes inside the constructor.\n\n# Older Versions of Python\n\nUnfortunately this does not work with `async` routes with Python versions less than 3.8 [due to bugs in\n`inspect.iscoroutinefunction`](https://stackoverflow.com/a/52422903/1431244). Specifically with older versions of Python\n`iscoroutinefunction` incorrectly returns false so `async` routes aren\'t `await`\'d. We therefore only support Python\nversions >= 3.8\n',
    'author': 'Oliver Dain',
    'author_email': 'oliver@dains.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://gitlab.com/companionlabs-opensource/classy-fastapi',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8',
}


setup(**setup_kwargs)
