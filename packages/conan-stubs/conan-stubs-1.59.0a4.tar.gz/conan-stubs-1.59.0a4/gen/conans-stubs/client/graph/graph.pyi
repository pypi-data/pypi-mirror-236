from _typeshed import Incomplete
from collections.abc import Generator
from conans.model.ref import PackageReference as PackageReference

RECIPE_DOWNLOADED: str
RECIPE_INCACHE: str
RECIPE_UPDATED: str
RECIPE_NEWER: str
RECIPE_NOT_IN_REMOTE: str
RECIPE_UPDATEABLE: str
RECIPE_NO_REMOTE: str
RECIPE_EDITABLE: str
RECIPE_CONSUMER: str
RECIPE_VIRTUAL: str
BINARY_CACHE: str
BINARY_DOWNLOAD: str
BINARY_UPDATE: str
BINARY_BUILD: str
BINARY_MISSING: str
BINARY_SKIP: str
BINARY_EDITABLE: str
BINARY_UNKNOWN: str
BINARY_INVALID: str
CONTEXT_HOST: str
CONTEXT_BUILD: str

class _NodeOrderedDict:
    _nodes: Incomplete
    def __init__(self) -> None: ...
    @staticmethod
    def _key(node): ...
    def add(self, node) -> None: ...
    def get(self, name, context): ...
    def pop(self, name, context): ...
    def sort(self, key_fn): ...
    def assign(self, other) -> None: ...
    def __iter__(self): ...

class Node:
    ref: Incomplete
    path: Incomplete
    _package_id: Incomplete
    prev: Incomplete
    conanfile: Incomplete
    dependencies: Incomplete
    dependants: Incomplete
    binary: Incomplete
    recipe: Incomplete
    remote: Incomplete
    binary_remote: Incomplete
    revision_pinned: bool
    context: Incomplete
    _public_deps: Incomplete
    _public_closure: Incomplete
    _transitive_closure: Incomplete
    inverse_closure: Incomplete
    _ancestors: Incomplete
    _id: Incomplete
    graph_lock_node: Incomplete
    id_direct_prefs: Incomplete
    id_indirect_prefs: Incomplete
    cant_build: bool
    should_build: bool
    def __init__(self, ref, conanfile, context, recipe: Incomplete | None = ..., path: Incomplete | None = ...) -> None: ...
    @property
    def id(self): ...
    @property
    def package_id(self): ...
    @property
    def name(self): ...
    @property
    def pref(self): ...
    @property
    def public_deps(self): ...
    @property
    def public_closure(self): ...
    @property
    def transitive_closure(self): ...
    @property
    def ancestors(self): ...
    def partial_copy(self): ...
    def add_edge(self, edge) -> None: ...
    def neighbors(self): ...
    def private_neighbors(self): ...
    def connect_closure(self, other_node) -> None: ...
    def inverse_neighbors(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __repr__(self): ...
    def __cmp__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __ge__(self, other): ...

class Edge:
    src: Incomplete
    dst: Incomplete
    require: Incomplete
    def __init__(self, src, dst, require) -> None: ...
    @property
    def private(self): ...
    @property
    def build_require(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class DepsGraph:
    nodes: Incomplete
    root: Incomplete
    aliased: Incomplete
    new_aliased: Incomplete
    _node_counter: Incomplete
    def __init__(self, initial_node_id: Incomplete | None = ...) -> None: ...
    def add_node(self, node) -> None: ...
    def add_edge(self, src, dst, require) -> None: ...
    def ordered_iterate(self, nodes_subset: Incomplete | None = ...) -> Generator[Incomplete, None, None]: ...
    def _inverse_closure(self, references): ...
    def collapse_graph(self): ...
    def build_order(self, references): ...
    def nodes_to_build(self): ...
    def by_levels(self, nodes_subset: Incomplete | None = ...): ...
    def inverse_levels(self): ...
    def _order_levels(self, direct, nodes_subset: Incomplete | None = ...): ...
    def mark_private_skippable(self, nodes_subset: Incomplete | None = ..., root: Incomplete | None = ...) -> None: ...
    def build_time_nodes(self): ...
