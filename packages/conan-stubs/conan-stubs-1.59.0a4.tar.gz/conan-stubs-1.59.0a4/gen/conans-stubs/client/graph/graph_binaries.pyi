from _typeshed import Incomplete
from conans.client.graph.build_mode import BuildMode as BuildMode
from conans.client.graph.compatibility import BinaryCompatibility as BinaryCompatibility
from conans.client.graph.graph import BINARY_BUILD as BINARY_BUILD, BINARY_CACHE as BINARY_CACHE, BINARY_DOWNLOAD as BINARY_DOWNLOAD, BINARY_EDITABLE as BINARY_EDITABLE, BINARY_INVALID as BINARY_INVALID, BINARY_MISSING as BINARY_MISSING, BINARY_SKIP as BINARY_SKIP, BINARY_UNKNOWN as BINARY_UNKNOWN, BINARY_UPDATE as BINARY_UPDATE, RECIPE_CONSUMER as RECIPE_CONSUMER, RECIPE_EDITABLE as RECIPE_EDITABLE, RECIPE_VIRTUAL as RECIPE_VIRTUAL
from conans.errors import ConanException as ConanException, ConanInvalidConfiguration as ConanInvalidConfiguration, NoRemoteAvailable as NoRemoteAvailable, NotFoundException as NotFoundException, conanfile_exception_formatter as conanfile_exception_formatter
from conans.model.info import ConanInfo as ConanInfo, PACKAGE_ID_INVALID as PACKAGE_ID_INVALID, PACKAGE_ID_UNKNOWN as PACKAGE_ID_UNKNOWN
from conans.model.manifest import FileTreeManifest as FileTreeManifest
from conans.model.ref import PackageReference as PackageReference
from conans.util.conan_v2_mode import conan_v2_property as conan_v2_property

class GraphBinariesAnalyzer:
    _cache: Incomplete
    _out: Incomplete
    _remote_manager: Incomplete
    _evaluated: Incomplete
    _fixed_package_id: Incomplete
    _compatibility: Incomplete
    def __init__(self, cache, output, remote_manager) -> None: ...
    @staticmethod
    def _check_update(upstream_manifest, package_folder, output): ...
    @staticmethod
    def _evaluate_build(node, build_mode): ...
    def _evaluate_clean_pkg_folder_dirty(self, node, package_layout, pref): ...
    def _evaluate_cache_pkg(self, node, package_layout, pref, metadata, remote, remotes, update) -> None: ...
    def _get_package_info(self, node, pref, remote): ...
    def _evaluate_remote_pkg(self, node, pref, remote, remotes, remote_selected): ...
    def _evaluate_is_cached(self, node, pref): ...
    def _evaluate_node(self, node, build_mode, update, remotes) -> None: ...
    def _process_node(self, node, pref, build_mode, update, remotes) -> None: ...
    @staticmethod
    def _propagate_options(node) -> None: ...
    @staticmethod
    def package_id_transitive_reqs(node): ...
    def _compute_package_id(self, node, default_package_id_mode, default_python_requires_id_mode) -> None: ...
    def evaluate_graph(self, deps_graph, build_mode, update, remotes, nodes_subset: Incomplete | None = ..., root: Incomplete | None = ...) -> None: ...
    def reevaluate_node(self, node, remotes, build_mode, update) -> None: ...
