from _typeshed import Incomplete
from conans import DEFAULT_REVISION_V1 as DEFAULT_REVISION_V1
from conans.client.graph.graph import RECIPE_CONSUMER as RECIPE_CONSUMER, RECIPE_VIRTUAL as RECIPE_VIRTUAL
from conans.client.graph.python_requires import PyRequires as PyRequires
from conans.client.graph.range_resolver import satisfying as satisfying
from conans.client.profile_loader import _load_profile as _load_profile
from conans.errors import ConanException as ConanException
from conans.model.info import PACKAGE_ID_UNKNOWN as PACKAGE_ID_UNKNOWN
from conans.model.options import OptionsValues as OptionsValues
from conans.model.ref import ConanFileReference as ConanFileReference
from conans.util.files import load as load, save as save

LOCKFILE: str
LOCKFILE_VERSION: str

class GraphLockFile:
    _profile_host: Incomplete
    _profile_build: Incomplete
    _graph_lock: Incomplete
    def __init__(self, profile_host, profile_build, graph_lock) -> None: ...
    @property
    def graph_lock(self): ...
    @property
    def profile_host(self): ...
    @property
    def profile_build(self): ...
    @staticmethod
    def load(path, revisions_enabled): ...
    def save(self, path) -> None: ...
    @staticmethod
    def _loads(text, revisions_enabled): ...
    def _dumps(self, path): ...
    def only_recipes(self) -> None: ...

class GraphLockNode:
    _ref: Incomplete
    _package_id: Incomplete
    _context: Incomplete
    _prev: Incomplete
    _requires: Incomplete
    _build_requires: Incomplete
    _python_requires: Incomplete
    _options: Incomplete
    _revisions_enabled: Incomplete
    _relaxed: bool
    _modified: Incomplete
    _path: Incomplete
    def __init__(self, ref, package_id, prev, python_requires, options, requires, build_requires, path, revisions_enabled, context, modified: Incomplete | None = ...) -> None: ...
    @property
    def context(self): ...
    @property
    def requires(self): ...
    @property
    def modified(self): ...
    @property
    def build_requires(self): ...
    def relax(self) -> None: ...
    def clean_modified(self) -> None: ...
    @property
    def path(self): ...
    @property
    def ref(self): ...
    @property
    def python_requires(self): ...
    @ref.setter
    def ref(self, value) -> None: ...
    @property
    def package_id(self): ...
    @property
    def prev(self): ...
    def unlock_prev(self) -> None: ...
    def complete_base_node(self, package_id, prev) -> None: ...
    @property
    def options(self): ...
    def only_recipe(self) -> None: ...
    @staticmethod
    def deserialize(data, revisions_enabled): ...
    def serialize(self): ...

class GraphLock:
    _nodes: Incomplete
    _revisions_enabled: Incomplete
    _relaxed: bool
    def __init__(self, deps_graph, revisions_enabled) -> None: ...
    @property
    def nodes(self): ...
    def relax(self) -> None: ...
    @property
    def relaxed(self): ...
    def clean_modified(self) -> None: ...
    def build_order(self): ...
    def complete_matching_prevs(self) -> None: ...
    def only_recipes(self) -> None: ...
    @property
    def initial_counter(self): ...
    def root_node_id(self): ...
    @staticmethod
    def deserialize(data, revisions_enabled): ...
    def serialize(self): ...
    def update_lock(self, new_lock) -> None: ...
    def pre_lock_node(self, node) -> None: ...
    def lock_node(self, node, requires, build_requires: bool = ...) -> None: ...
    def check_locked_build_requires(self, node, package_build_requires, profile_build_requires) -> None: ...
    def python_requires(self, node_id): ...
    def _match_relaxed_require(self, ref): ...
    def _find_first(self, predicate): ...
    def get_consumer(self, ref): ...
    def find_require_and_lock(self, reference, conanfile, lockfile_node_id: Incomplete | None = ...) -> None: ...
    def _find_node_by_requirement(self, ref): ...
    def update_exported_ref(self, node_id, ref) -> None: ...
