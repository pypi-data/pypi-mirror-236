from _typeshed import Incomplete
from collections import OrderedDict
from conans.client.conanfile.configure import run_configure_method as run_configure_method
from conans.client.generators.text import TXTGenerator as TXTGenerator
from conans.client.graph.build_mode import BuildMode as BuildMode
from conans.client.graph.graph import BINARY_BUILD as BINARY_BUILD, CONTEXT_BUILD as CONTEXT_BUILD, CONTEXT_HOST as CONTEXT_HOST, Node as Node
from conans.client.graph.graph_binaries import BINARY_EDITABLE as BINARY_EDITABLE, BINARY_UNKNOWN as BINARY_UNKNOWN, RECIPE_CONSUMER as RECIPE_CONSUMER, RECIPE_VIRTUAL as RECIPE_VIRTUAL
from conans.client.graph.graph_builder import DepsGraphBuilder as DepsGraphBuilder
from conans.errors import ConanException as ConanException, conanfile_exception_formatter as conanfile_exception_formatter
from conans.model.conan_file import get_env_context_manager as get_env_context_manager
from conans.model.graph_info import GraphInfo as GraphInfo
from conans.model.graph_lock import GraphLock as GraphLock, GraphLockFile as GraphLockFile
from conans.model.ref import ConanFileReference as ConanFileReference
from conans.paths import BUILD_INFO as BUILD_INFO
from conans.util.files import load as load

class _RecipeBuildRequires(OrderedDict):
    _default_context: Incomplete
    def __init__(self, conanfile, default_context) -> None: ...
    def add(self, build_require, context, force_host_context: bool = ...) -> None: ...
    def __call__(self, build_require, force_host_context: bool = ...) -> None: ...
    def __str__(self): ...

class GraphManager:
    _proxy: Incomplete
    _output: Incomplete
    _resolver: Incomplete
    _cache: Incomplete
    _remote_manager: Incomplete
    _loader: Incomplete
    _binary_analyzer: Incomplete
    def __init__(self, output, cache, remote_manager, loader, proxy, resolver, binary_analyzer) -> None: ...
    def load_consumer_conanfile(self, conanfile_path, info_folder, deps_info_required: bool = ..., test: bool = ...): ...
    def load_graph(self, reference, create_reference, graph_info, build_mode, check_updates, update, remotes, recorder, apply_build_requires: bool = ..., lockfile_node_id: Incomplete | None = ..., is_build_require: bool = ..., require_overrides: Incomplete | None = ...): ...
    def _load_root_node(self, reference, create_reference, profile_host, graph_lock, root_ref, lockfile_node_id, is_build_require, require_overrides): ...
    def _load_root_consumer(self, path, graph_lock, profile, ref, require_overrides): ...
    def _load_root_direct_reference(self, reference, graph_lock, profile, lockfile_node_id, is_build_require, require_overrides): ...
    def _load_root_test_package(self, path, create_reference, graph_lock, profile, require_overrides): ...
    def _resolve_graph(self, root_node, profile_host, profile_build, graph_lock, build_mode, check_updates, update, remotes, recorder, apply_build_requires: bool = ...): ...
    _build_requires: Incomplete
    @staticmethod
    def _get_recipe_build_requires(conanfile, default_context): ...
    def _recurse_build_requires(self, graph, builder, check_updates, update, build_mode, remotes, profile_build_requires, recorder, profile_host, profile_build, graph_lock, apply_build_requires: bool = ..., nodes_subset: Incomplete | None = ..., root: Incomplete | None = ...) -> None: ...
    def _load_graph(self, root_node, check_updates, update, build_mode, remotes, recorder, profile_host, profile_build, apply_build_requires, graph_lock): ...
    @staticmethod
    def _validate_graph_provides(deps_graph): ...

def load_deps_info(current_path, conanfile, required): ...
