# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_glean_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_glean_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_glean_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder(*args):
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consumeWithStream")
        finally:
            self.free()

    @contextlib.contextmanager
    def readWithStream(self):
        """Context-manager to read a buffer using a RustBufferStream.

        This is like consumeWithStream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `RustBuffer` data.
        """
        s = RustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of readWithStream")

class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream:
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")

    def readCSizeT(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class RustBufferBuilder:
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)

    def writeCSizeT(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def rust_call_async(scaffolding_fn, callback_fn, *args):
    # Call the scaffolding function, passing it a callback handler for `AsyncTypes.py` and a pointer
    # to a python Future object.  The async function then awaits the Future.
    uniffi_eventloop = asyncio.get_running_loop()
    uniffi_py_future = uniffi_eventloop.create_future()
    uniffi_call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))
    scaffolding_fn(*args,
       FfiConverterForeignExecutor._pointer_manager.new_pointer(uniffi_eventloop),
       callback_fn,
       # Note: It's tempting to skip the pointer manager and just use a `py_object` pointing to a
       # local variable like we do in Swift.  However, Python doesn't use cooperative cancellation
       # -- asyncio can cancel a task at anytime.  This means if we use a local variable, the Rust
       # callback could fire with a dangling pointer.
       UniFfiPyFuturePointerManager.new_pointer(uniffi_py_future),
       ctypes.byref(uniffi_call_status),
    )
    uniffi_check_call_status(None, uniffi_call_status)
    return uniffi_py_future

def uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(RustBuffer))
class UniFfiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See UniFfiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class UniFfiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as UniFfiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    UniFfiPointerManager = UniFfiPointerManagerCPython  # type: ignore
else:
    UniFfiPointerManager = UniFfiPointerManagerGeneral  # type: ignore
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.writeUnchecked(cls.check(value), buf)

class FfiConverterPrimitiveInt(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class FfiConverterPrimitiveFloat(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)

def uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, RustCallStatus)

from pathlib import Path

def loadIndirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("glean_ffi")
    path = str(Path(__file__).parent / libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 22
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_glean_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def uniffi_check_api_checksums(lib):
    if lib.uniffi_glean_checksum_func_glean_enable_logging() != 39784:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_enable_logging_to_fd() != 2751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_initialize() != 48266:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_shutdown() != 52890:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_initialize_for_subprocess() != 41714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_upload_enabled() != 25426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_experiment_active() != 21908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_experiment_inactive() != 58468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_test_get_experiment_data() != 43392:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_test_get_experimentation_id() != 23734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_metrics_enabled_config() != 25366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_debug_view_tag() != 21824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_source_tags() != 4907:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_log_pings() != 36545:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_handle_client_active() != 56137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_handle_client_inactive() != 48873:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_submit_ping_by_name() != 40897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_submit_ping_by_name_sync() != 34196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_test_mode() != 55989:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_test_destroy_glean() != 4316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_set_dirty_flag() != 39520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_get_upload_task() != 49767:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_func_glean_process_ping_upload_response() != 65422:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_pingtype_submit() != 50962:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_countermetric_add() != 47365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_countermetric_test_get_value() != 63058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_countermetric_test_get_num_recorded_errors() != 56124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_start() != 6571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_stop() != 21546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_cancel() != 59596:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_set_raw_nanos() != 39042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_test_get_value() != 7894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timespanmetric_test_get_num_recorded_errors() != 11762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_booleanmetric_set() != 597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_booleanmetric_test_get_value() != 35783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_booleanmetric_test_get_num_recorded_errors() != 60626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringmetric_set() != 62613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringmetric_test_get_value() != 16095:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringmetric_test_get_num_recorded_errors() != 57742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledcounter_get() != 7248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledcounter_test_get_num_recorded_errors() != 26211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledboolean_get() != 4867:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledboolean_test_get_num_recorded_errors() != 15724:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledstring_get() != 5522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_labeledstring_test_get_num_recorded_errors() != 13978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringlistmetric_add() != 31024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringlistmetric_set() != 41402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringlistmetric_test_get_value() != 1464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_stringlistmetric_test_get_num_recorded_errors() != 8313:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_urlmetric_set() != 36199:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_urlmetric_test_get_value() != 58592:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_urlmetric_test_get_num_recorded_errors() != 907:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_uuidmetric_set() != 49112:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_uuidmetric_generate_and_set() != 34901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_uuidmetric_test_get_value() != 32480:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_uuidmetric_test_get_num_recorded_errors() != 8136:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_quantitymetric_set() != 51163:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_quantitymetric_test_get_value() != 35617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_quantitymetric_test_get_num_recorded_errors() != 59228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_start() != 31196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_stop_and_accumulate() != 41024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_cancel() != 22:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_accumulate_samples() != 9160:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_value() != 3198:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_num_recorded_errors() != 35988:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate() != 46433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate_samples() != 27274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_value() != 8859:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_num_recorded_errors() != 62949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_customdistributionmetric_accumulate_samples() != 14500:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_customdistributionmetric_test_get_value() != 55411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_customdistributionmetric_test_get_num_recorded_errors() != 51470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_datetimemetric_set() != 16725:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_datetimemetric_test_get_value() != 5927:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_datetimemetric_test_get_value_as_string() != 34220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_datetimemetric_test_get_num_recorded_errors() != 16978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_eventmetric_record() != 37189:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_eventmetric_test_get_value() != 36379:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_eventmetric_test_get_num_recorded_errors() != 6822:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_ratemetric_add_to_numerator() != 64130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_ratemetric_add_to_denominator() != 17127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_ratemetric_test_get_value() != 21743:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_ratemetric_test_get_num_recorded_errors() != 8700:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_denominatormetric_add() != 59124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_denominatormetric_test_get_value() != 22854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_denominatormetric_test_get_num_recorded_errors() != 51262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_numeratormetric_add_to_numerator() != 37957:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_numeratormetric_test_get_value() != 44879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_numeratormetric_test_get_num_recorded_errors() != 38290:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_textmetric_set() != 30509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_textmetric_test_get_value() != 60778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_method_textmetric_test_get_num_recorded_errors() != 6599:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_pingtype_new() != 62122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_countermetric_new() != 5972:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_timespanmetric_new() != 44267:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_booleanmetric_new() != 18167:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_stringmetric_new() != 43908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_labeledcounter_new() != 56816:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_labeledboolean_new() != 2276:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_labeledstring_new() != 64086:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_stringlistmetric_new() != 6498:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_urlmetric_new() != 36209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_uuidmetric_new() != 42995:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_quantitymetric_new() != 22435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_timingdistributionmetric_new() != 41739:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_memorydistributionmetric_new() != 36126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_customdistributionmetric_new() != 13801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_datetimemetric_new() != 2028:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_eventmetric_new() != 17257:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_ratemetric_new() != 64152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_denominatormetric_new() != 21109:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_numeratormetric_new() != 19205:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_checksum_constructor_textmetric_new() != 40789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.uniffi_glean_fn_free_pingtype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_pingtype.restype = None
_UniFFILib.uniffi_glean_fn_constructor_pingtype_new.argtypes = (
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.c_int8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_pingtype_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_pingtype_submit.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_pingtype_submit.restype = None
_UniFFILib.uniffi_glean_fn_free_countermetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_countermetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_countermetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_countermetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_countermetric_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_countermetric_add.restype = None
_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_timespanmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_timespanmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_timespanmetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_timespanmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_timespanmetric_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_start.restype = None
_UniFFILib.uniffi_glean_fn_method_timespanmetric_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_stop.restype = None
_UniFFILib.uniffi_glean_fn_method_timespanmetric_cancel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_cancel.restype = None
_UniFFILib.uniffi_glean_fn_method_timespanmetric_set_raw_nanos.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_set_raw_nanos.restype = None
_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_booleanmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_booleanmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_booleanmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_booleanmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_booleanmetric_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_booleanmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_stringmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_stringmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_stringmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_stringmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_stringmetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_labeledcounter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_labeledcounter.restype = None
_UniFFILib.uniffi_glean_fn_constructor_labeledcounter_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_labeledcounter_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledcounter_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledcounter_get.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledcounter_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledcounter_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_labeledboolean.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_labeledboolean.restype = None
_UniFFILib.uniffi_glean_fn_constructor_labeledboolean_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_labeledboolean_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledboolean_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledboolean_get.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledboolean_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledboolean_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_labeledstring.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_labeledstring.restype = None
_UniFFILib.uniffi_glean_fn_constructor_labeledstring_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_labeledstring_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledstring_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledstring_get.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_labeledstring_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_labeledstring_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_stringlistmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_stringlistmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_stringlistmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_stringlistmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_add.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_add.restype = None
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_urlmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_urlmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_urlmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_urlmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_urlmetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_urlmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_uuidmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_uuidmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_uuidmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_uuidmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_uuidmetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_uuidmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_uuidmetric_generate_and_set.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_uuidmetric_generate_and_set.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_quantitymetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_quantitymetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_quantitymetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_quantitymetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_quantitymetric_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_quantitymetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_timingdistributionmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_timingdistributionmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_timingdistributionmetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_timingdistributionmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_start.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_stop_and_accumulate.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_stop_and_accumulate.restype = None
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_cancel.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_cancel.restype = None
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_accumulate_samples.restype = None
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_memorydistributionmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_memorydistributionmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_memorydistributionmetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_memorydistributionmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate.restype = None
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate_samples.restype = None
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_customdistributionmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_customdistributionmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_customdistributionmetric_new.argtypes = (
    RustBuffer,
    ctypes.c_int64,
    ctypes.c_int64,
    ctypes.c_int64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_customdistributionmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_accumulate_samples.restype = None
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_datetimemetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_datetimemetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_datetimemetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_datetimemetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_datetimemetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_datetimemetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value_as_string.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value_as_string.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_eventmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_eventmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_eventmetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_eventmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_eventmetric_record.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_eventmetric_record.restype = None
_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_ratemetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_ratemetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_ratemetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_ratemetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_numerator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_numerator.restype = None
_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_denominator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_denominator.restype = None
_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_denominatormetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_denominatormetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_denominatormetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_denominatormetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_denominatormetric_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_denominatormetric_add.restype = None
_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_numeratormetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_numeratormetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_numeratormetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_numeratormetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_numeratormetric_add_to_numerator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_numeratormetric_add_to_numerator.restype = None
_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_free_textmetric.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_free_textmetric.restype = None
_UniFFILib.uniffi_glean_fn_constructor_textmetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_constructor_textmetric_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_glean_fn_method_textmetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_textmetric_set.restype = None
_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_value.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.uniffi_glean_fn_init_callback_ongleanevents.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_init_callback_ongleanevents.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_enable_logging.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_enable_logging.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_enable_logging_to_fd.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_enable_logging_to_fd.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_initialize.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_initialize.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_shutdown.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_shutdown.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_initialize_for_subprocess.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_initialize_for_subprocess.restype = ctypes.c_int8
_UniFFILib.uniffi_glean_fn_func_glean_set_upload_enabled.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_upload_enabled.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_active.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_active.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_inactive.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_inactive.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_test_get_experiment_data.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_test_get_experiment_data.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_func_glean_test_get_experimentation_id.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_test_get_experimentation_id.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_func_glean_set_metrics_enabled_config.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_metrics_enabled_config.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_set_debug_view_tag.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_debug_view_tag.restype = ctypes.c_int8
_UniFFILib.uniffi_glean_fn_func_glean_set_source_tags.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_source_tags.restype = ctypes.c_int8
_UniFFILib.uniffi_glean_fn_func_glean_set_log_pings.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_log_pings.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_handle_client_active.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_handle_client_active.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_handle_client_inactive.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_handle_client_inactive.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name_sync.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name_sync.restype = ctypes.c_int8
_UniFFILib.uniffi_glean_fn_func_glean_set_test_mode.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_test_mode.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_test_destroy_glean.argtypes = (
    ctypes.c_int8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_test_destroy_glean.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_set_dirty_flag.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_set_dirty_flag.restype = None
_UniFFILib.uniffi_glean_fn_func_glean_get_upload_task.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_get_upload_task.restype = RustBuffer
_UniFFILib.uniffi_glean_fn_func_glean_process_ping_upload_response.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_glean_fn_func_glean_process_ping_upload_response.restype = RustBuffer
_UniFFILib.ffi_glean_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_glean_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_glean_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_rustbuffer_free.restype = None
_UniFFILib.ffi_glean_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_rustbuffer_reserve.restype = RustBuffer
_UniFFILib.uniffi_glean_checksum_func_glean_enable_logging.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_enable_logging.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_enable_logging_to_fd.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_enable_logging_to_fd.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_initialize.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_initialize.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_shutdown.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_shutdown.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_initialize_for_subprocess.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_initialize_for_subprocess.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_upload_enabled.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_upload_enabled.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_experiment_active.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_experiment_active.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_experiment_inactive.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_experiment_inactive.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_test_get_experiment_data.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_test_get_experiment_data.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_test_get_experimentation_id.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_test_get_experimentation_id.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_metrics_enabled_config.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_metrics_enabled_config.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_debug_view_tag.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_debug_view_tag.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_source_tags.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_source_tags.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_log_pings.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_log_pings.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_handle_client_active.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_handle_client_active.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_handle_client_inactive.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_handle_client_inactive.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_submit_ping_by_name.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_submit_ping_by_name.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_submit_ping_by_name_sync.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_submit_ping_by_name_sync.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_test_mode.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_test_mode.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_test_destroy_glean.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_test_destroy_glean.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_set_dirty_flag.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_set_dirty_flag.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_get_upload_task.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_get_upload_task.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_func_glean_process_ping_upload_response.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_func_glean_process_ping_upload_response.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_pingtype_submit.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_pingtype_submit.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_countermetric_add.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_countermetric_add.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_countermetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_countermetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_countermetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_countermetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_start.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_start.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_stop.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_stop.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_cancel.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_cancel.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_set_raw_nanos.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_set_raw_nanos.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timespanmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_booleanmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledcounter_get.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledcounter_get.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledcounter_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledcounter_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledboolean_get.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledboolean_get.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledboolean_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledboolean_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledstring_get.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledstring_get.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_labeledstring_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_labeledstring_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_add.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_add.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_stringlistmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_urlmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_urlmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_urlmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_urlmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_urlmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_urlmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_generate_and_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_generate_and_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_uuidmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_quantitymetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_start.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_start.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_stop_and_accumulate.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_stop_and_accumulate.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_cancel.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_cancel.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_accumulate_samples.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_timingdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate_samples.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_memorydistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_accumulate_samples.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_customdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_value_as_string.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_value_as_string.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_datetimemetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_eventmetric_record.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_eventmetric_record.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_eventmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_eventmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_eventmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_eventmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_ratemetric_add_to_numerator.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_ratemetric_add_to_numerator.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_ratemetric_add_to_denominator.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_ratemetric_add_to_denominator.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_ratemetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_ratemetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_ratemetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_ratemetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_add.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_add.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_denominatormetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_add_to_numerator.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_add_to_numerator.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_numeratormetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_textmetric_set.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_textmetric_set.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_textmetric_test_get_value.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_textmetric_test_get_value.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_method_textmetric_test_get_num_recorded_errors.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_method_textmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_pingtype_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_pingtype_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_countermetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_countermetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_timespanmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_timespanmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_booleanmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_booleanmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_stringmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_stringmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_labeledcounter_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_labeledcounter_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_labeledboolean_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_labeledboolean_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_labeledstring_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_labeledstring_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_stringlistmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_stringlistmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_urlmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_urlmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_uuidmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_uuidmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_quantitymetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_quantitymetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_timingdistributionmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_timingdistributionmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_memorydistributionmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_memorydistributionmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_customdistributionmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_customdistributionmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_datetimemetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_datetimemetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_eventmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_eventmetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_ratemetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_ratemetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_denominatormetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_denominatormetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_numeratormetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_numeratormetric_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_glean_checksum_constructor_textmetric_new.argtypes = (
)
_UniFFILib.uniffi_glean_checksum_constructor_textmetric_new.restype = ctypes.c_uint16
_UniFFILib.ffi_glean_uniffi_contract_version.argtypes = (
)
_UniFFILib.ffi_glean_uniffi_contract_version.restype = ctypes.c_uint32
uniffi_check_contract_api_version(_UniFFILib)
uniffi_check_api_checksums(_UniFFILib)

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU8(value)

class FfiConverterInt8(FfiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -2**7
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.readI8()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeI8(value)

class FfiConverterUInt32(FfiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU32(value)

class FfiConverterInt32(FfiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.readI32()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeI32(value)

class FfiConverterUInt64(FfiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeI64(value)

class FfiConverterBool(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def writeUnchecked(cls, value, buf):
        buf.writeU8(value)

    @staticmethod
    def lift(value):
        return value != 0

class FfiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = FfiConverterString.check(value)
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = FfiConverterString.check(value)
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BooleanMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_booleanmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_booleanmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "bool"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_booleanmetric_set,self._pointer,
        FfiConverterBool.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[bool]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalBool.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_booleanmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeBooleanMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BooleanMetric):
            raise TypeError("Expected BooleanMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BooleanMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CounterMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_countermetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_countermetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add(self, amount: "typing.Union[object, int]" = DEFAULT):
        if amount is DEFAULT:
            amount = 1
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_countermetric_add,self._pointer,
        FfiConverterInt32.lower(amount))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[int]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_countermetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeCounterMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CounterMetric):
            raise TypeError("Expected CounterMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CounterMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CustomDistributionMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",range_min: "int",range_max: "int",bucket_count: "int",histogram_type: "HistogramType"):
        
        
        
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_customdistributionmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterInt64.lower(range_min),
        FfiConverterInt64.lower(range_max),
        FfiConverterInt64.lower(bucket_count),
        FfiConverterTypeHistogramType.lower(histogram_type))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_customdistributionmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def accumulate_samples(self, samples: "typing.List[int]"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[DistributionData]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_customdistributionmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeCustomDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CustomDistributionMetric):
            raise TypeError("Expected CustomDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CustomDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DatetimeMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",time_unit: "TimeUnit"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_datetimemetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_datetimemetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "typing.Union[object, typing.Optional[Datetime]]" = DEFAULT):
        if value is DEFAULT:
            value = None
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_datetimemetric_set,self._pointer,
        FfiConverterOptionalTypeDatetime.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[Datetime]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeDatetime.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_value_as_string(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[str]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_value_as_string,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_datetimemetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeDatetimeMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DatetimeMetric):
            raise TypeError("Expected DatetimeMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DatetimeMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DenominatorMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",numerators: "typing.List[CommonMetricData]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_denominatormetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterSequenceTypeCommonMetricData.lower(numerators))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_denominatormetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add(self, amount: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_denominatormetric_add,self._pointer,
        FfiConverterInt32.lower(amount))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[int]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_denominatormetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeDenominatorMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DenominatorMetric):
            raise TypeError("Expected DenominatorMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DenominatorMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",allowed_extra_keys: "typing.List[str]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_eventmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterSequenceString.lower(allowed_extra_keys))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_eventmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def record(self, extra: "dict"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_eventmetric_record,self._pointer,
        FfiConverterMapStringString.lower(extra))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[typing.List[RecordedEvent]]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalSequenceTypeRecordedEvent.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_eventmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeEventMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventMetric):
            raise TypeError("Expected EventMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledBoolean:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",labels: "typing.Optional[typing.List[CowString]]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_labeledboolean_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_labeledboolean, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get(self, label: "str") -> "BooleanMetric":
        
        return FfiConverterTypeBooleanMetric.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledboolean_get,self._pointer,
        FfiConverterString.lower(label))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledboolean_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeLabeledBoolean:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledBoolean):
            raise TypeError("Expected LabeledBoolean instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledBoolean._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledCounter:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",labels: "typing.Optional[typing.List[CowString]]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_labeledcounter_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_labeledcounter, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get(self, label: "str") -> "CounterMetric":
        
        return FfiConverterTypeCounterMetric.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledcounter_get,self._pointer,
        FfiConverterString.lower(label))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledcounter_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeLabeledCounter:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledCounter):
            raise TypeError("Expected LabeledCounter instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledCounter._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledString:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",labels: "typing.Optional[typing.List[CowString]]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_labeledstring_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_labeledstring, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get(self, label: "str") -> "StringMetric":
        
        return FfiConverterTypeStringMetric.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledstring_get,self._pointer,
        FfiConverterString.lower(label))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_labeledstring_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeLabeledString:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledString):
            raise TypeError("Expected LabeledString instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledString._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class MemoryDistributionMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",memory_unit: "MemoryUnit"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_memorydistributionmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeMemoryUnit.lower(memory_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_memorydistributionmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def accumulate(self, sample: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate,self._pointer,
        FfiConverterInt64.lower(sample))







    def accumulate_samples(self, samples: "typing.List[int]"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[DistributionData]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_memorydistributionmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeMemoryDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, MemoryDistributionMetric):
            raise TypeError("Expected MemoryDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return MemoryDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NumeratorMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_numeratormetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_numeratormetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_to_numerator(self, amount: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_numeratormetric_add_to_numerator,self._pointer,
        FfiConverterInt32.lower(amount))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[Rate]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeRate.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_numeratormetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeNumeratorMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NumeratorMetric):
            raise TypeError("Expected NumeratorMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NumeratorMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PingType:
    _pointer: ctypes.c_void_p
    def __init__(self, name: "str",include_client_id: "bool",send_if_empty: "bool",precise_timestamps: "bool",reason_codes: "typing.List[str]"):
        
        
        
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_pingtype_new,
        FfiConverterString.lower(name),
        FfiConverterBool.lower(include_client_id),
        FfiConverterBool.lower(send_if_empty),
        FfiConverterBool.lower(precise_timestamps),
        FfiConverterSequenceString.lower(reason_codes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_pingtype, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def submit(self, reason: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
        if reason is DEFAULT:
            reason = None
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_pingtype_submit,self._pointer,
        FfiConverterOptionalString.lower(reason))







class FfiConverterTypePingType:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PingType):
            raise TypeError("Expected PingType instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PingType._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class QuantityMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_quantitymetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_quantitymetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_quantitymetric_set,self._pointer,
        FfiConverterInt64.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[int]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalInt64.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_quantitymetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeQuantityMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, QuantityMetric):
            raise TypeError("Expected QuantityMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return QuantityMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RateMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_ratemetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_ratemetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_to_numerator(self, amount: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_numerator,self._pointer,
        FfiConverterInt32.lower(amount))







    def add_to_denominator(self, amount: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_ratemetric_add_to_denominator,self._pointer,
        FfiConverterInt32.lower(amount))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[Rate]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeRate.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_ratemetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeRateMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RateMetric):
            raise TypeError("Expected RateMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RateMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StringListMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_stringlistmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_stringlistmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add(self, value: "str"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_stringlistmetric_add,self._pointer,
        FfiConverterString.lower(value))







    def set(self, value: "typing.List[str]"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_stringlistmetric_set,self._pointer,
        FfiConverterSequenceString.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[typing.List[str]]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalSequenceString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_stringlistmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeStringListMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StringListMetric):
            raise TypeError("Expected StringListMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StringListMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StringMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_stringmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_stringmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "str"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_stringmetric_set,self._pointer,
        FfiConverterString.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[str]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_stringmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeStringMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StringMetric):
            raise TypeError("Expected StringMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StringMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TextMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_textmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_textmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "str"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_textmetric_set,self._pointer,
        FfiConverterString.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[str]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_textmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeTextMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TextMetric):
            raise TypeError("Expected TextMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TextMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TimespanMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",time_unit: "TimeUnit"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_timespanmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_timespanmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def start(self, ):
        rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_start,self._pointer,)







    def stop(self, ):
        rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_stop,self._pointer,)







    def cancel(self, ):
        rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_cancel,self._pointer,)







    def set_raw_nanos(self, elapsed: "int"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_set_raw_nanos,self._pointer,
        FfiConverterInt64.lower(elapsed))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[int]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalInt64.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_timespanmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeTimespanMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TimespanMetric):
            raise TypeError("Expected TimespanMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TimespanMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TimingDistributionMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData",time_unit: "TimeUnit"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_timingdistributionmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_timingdistributionmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def start(self, ) -> "TimerId":
        return FfiConverterTypeTimerId.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_start,self._pointer,)
        )






    def stop_and_accumulate(self, timer_id: "TimerId"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_stop_and_accumulate,self._pointer,
        FfiConverterTypeTimerId.lower(timer_id))







    def cancel(self, timer_id: "TimerId"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_cancel,self._pointer,
        FfiConverterTypeTimerId.lower(timer_id))







    def accumulate_samples(self, samples: "typing.List[int]"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[DistributionData]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_timingdistributionmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeTimingDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TimingDistributionMetric):
            raise TypeError("Expected TimingDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TimingDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UrlMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_urlmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_urlmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "str"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_urlmetric_set,self._pointer,
        FfiConverterString.lower(value))







    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[str]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_urlmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeUrlMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UrlMetric):
            raise TypeError("Expected UrlMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UrlMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UuidMetric:
    _pointer: ctypes.c_void_p
    def __init__(self, meta: "CommonMetricData"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_glean_fn_constructor_uuidmetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_glean_fn_free_uuidmetric, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def set(self, value: "str"):
        
        rust_call(_UniFFILib.uniffi_glean_fn_method_uuidmetric_set,self._pointer,
        FfiConverterString.lower(value))







    def generate_and_set(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_uuidmetric_generate_and_set,self._pointer,)
        )






    def test_get_value(self, ping_name: "typing.Union[object, typing.Optional[str]]" = DEFAULT) -> "typing.Optional[str]":
        if ping_name is DEFAULT:
            ping_name = None
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )






    def test_get_num_recorded_errors(self, error: "ErrorType") -> "int":
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.uniffi_glean_fn_method_uuidmetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )






class FfiConverterTypeUuidMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UuidMetric):
            raise TypeError("Expected UuidMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UuidMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ClientInfoMetrics:

    def __init__(self, app_build, app_display_version, app_build_date, architecture, os_version, channel = DEFAULT, locale = DEFAULT, device_manufacturer = DEFAULT, device_model = DEFAULT, android_sdk_version = DEFAULT, windows_build_number = DEFAULT):
        self.app_build = app_build
        self.app_display_version = app_display_version
        self.app_build_date = app_build_date
        self.architecture = architecture
        self.os_version = os_version
        if channel is DEFAULT:
            self.channel = None
        else:
            self.channel = channel
        if locale is DEFAULT:
            self.locale = None
        else:
            self.locale = locale
        if device_manufacturer is DEFAULT:
            self.device_manufacturer = None
        else:
            self.device_manufacturer = device_manufacturer
        if device_model is DEFAULT:
            self.device_model = None
        else:
            self.device_model = device_model
        if android_sdk_version is DEFAULT:
            self.android_sdk_version = None
        else:
            self.android_sdk_version = android_sdk_version
        if windows_build_number is DEFAULT:
            self.windows_build_number = None
        else:
            self.windows_build_number = windows_build_number

    def __str__(self):
        return "ClientInfoMetrics(app_build={}, app_display_version={}, app_build_date={}, architecture={}, os_version={}, channel={}, locale={}, device_manufacturer={}, device_model={}, android_sdk_version={}, windows_build_number={})".format(self.app_build, self.app_display_version, self.app_build_date, self.architecture, self.os_version, self.channel, self.locale, self.device_manufacturer, self.device_model, self.android_sdk_version, self.windows_build_number)

    def __eq__(self, other):
        if self.app_build != other.app_build:
            return False
        if self.app_display_version != other.app_display_version:
            return False
        if self.app_build_date != other.app_build_date:
            return False
        if self.architecture != other.architecture:
            return False
        if self.os_version != other.os_version:
            return False
        if self.channel != other.channel:
            return False
        if self.locale != other.locale:
            return False
        if self.device_manufacturer != other.device_manufacturer:
            return False
        if self.device_model != other.device_model:
            return False
        if self.android_sdk_version != other.android_sdk_version:
            return False
        if self.windows_build_number != other.windows_build_number:
            return False
        return True

class FfiConverterTypeClientInfoMetrics(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientInfoMetrics(
            app_build=FfiConverterString.read(buf),
            app_display_version=FfiConverterString.read(buf),
            app_build_date=FfiConverterTypeDatetime.read(buf),
            architecture=FfiConverterString.read(buf),
            os_version=FfiConverterString.read(buf),
            channel=FfiConverterOptionalString.read(buf),
            locale=FfiConverterOptionalString.read(buf),
            device_manufacturer=FfiConverterOptionalString.read(buf),
            device_model=FfiConverterOptionalString.read(buf),
            android_sdk_version=FfiConverterOptionalString.read(buf),
            windows_build_number=FfiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.app_build, buf)
        FfiConverterString.write(value.app_display_version, buf)
        FfiConverterTypeDatetime.write(value.app_build_date, buf)
        FfiConverterString.write(value.architecture, buf)
        FfiConverterString.write(value.os_version, buf)
        FfiConverterOptionalString.write(value.channel, buf)
        FfiConverterOptionalString.write(value.locale, buf)
        FfiConverterOptionalString.write(value.device_manufacturer, buf)
        FfiConverterOptionalString.write(value.device_model, buf)
        FfiConverterOptionalString.write(value.android_sdk_version, buf)
        FfiConverterOptionalInt64.write(value.windows_build_number, buf)


class CommonMetricData:

    def __init__(self, category, name, send_in_pings, lifetime, disabled, dynamic_label = DEFAULT):
        self.category = category
        self.name = name
        self.send_in_pings = send_in_pings
        self.lifetime = lifetime
        self.disabled = disabled
        if dynamic_label is DEFAULT:
            self.dynamic_label = None
        else:
            self.dynamic_label = dynamic_label

    def __str__(self):
        return "CommonMetricData(category={}, name={}, send_in_pings={}, lifetime={}, disabled={}, dynamic_label={})".format(self.category, self.name, self.send_in_pings, self.lifetime, self.disabled, self.dynamic_label)

    def __eq__(self, other):
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.send_in_pings != other.send_in_pings:
            return False
        if self.lifetime != other.lifetime:
            return False
        if self.disabled != other.disabled:
            return False
        if self.dynamic_label != other.dynamic_label:
            return False
        return True

class FfiConverterTypeCommonMetricData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CommonMetricData(
            category=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            send_in_pings=FfiConverterSequenceString.read(buf),
            lifetime=FfiConverterTypeLifetime.read(buf),
            disabled=FfiConverterBool.read(buf),
            dynamic_label=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.category, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterSequenceString.write(value.send_in_pings, buf)
        FfiConverterTypeLifetime.write(value.lifetime, buf)
        FfiConverterBool.write(value.disabled, buf)
        FfiConverterOptionalString.write(value.dynamic_label, buf)


class Datetime:

    def __init__(self, year, month, day, hour, minute, second, nanosecond, offset_seconds):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nanosecond = nanosecond
        self.offset_seconds = offset_seconds

    def __str__(self):
        return "Datetime(year={}, month={}, day={}, hour={}, minute={}, second={}, nanosecond={}, offset_seconds={})".format(self.year, self.month, self.day, self.hour, self.minute, self.second, self.nanosecond, self.offset_seconds)

    def __eq__(self, other):
        if self.year != other.year:
            return False
        if self.month != other.month:
            return False
        if self.day != other.day:
            return False
        if self.hour != other.hour:
            return False
        if self.minute != other.minute:
            return False
        if self.second != other.second:
            return False
        if self.nanosecond != other.nanosecond:
            return False
        if self.offset_seconds != other.offset_seconds:
            return False
        return True

class FfiConverterTypeDatetime(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Datetime(
            year=FfiConverterInt32.read(buf),
            month=FfiConverterUInt32.read(buf),
            day=FfiConverterUInt32.read(buf),
            hour=FfiConverterUInt32.read(buf),
            minute=FfiConverterUInt32.read(buf),
            second=FfiConverterUInt32.read(buf),
            nanosecond=FfiConverterUInt32.read(buf),
            offset_seconds=FfiConverterInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterInt32.write(value.year, buf)
        FfiConverterUInt32.write(value.month, buf)
        FfiConverterUInt32.write(value.day, buf)
        FfiConverterUInt32.write(value.hour, buf)
        FfiConverterUInt32.write(value.minute, buf)
        FfiConverterUInt32.write(value.second, buf)
        FfiConverterUInt32.write(value.nanosecond, buf)
        FfiConverterInt32.write(value.offset_seconds, buf)


class DistributionData:

    def __init__(self, values, sum, count):
        self.values = values
        self.sum = sum
        self.count = count

    def __str__(self):
        return "DistributionData(values={}, sum={}, count={})".format(self.values, self.sum, self.count)

    def __eq__(self, other):
        if self.values != other.values:
            return False
        if self.sum != other.sum:
            return False
        if self.count != other.count:
            return False
        return True

class FfiConverterTypeDistributionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DistributionData(
            values=FfiConverterMapInt64Int64.read(buf),
            sum=FfiConverterInt64.read(buf),
            count=FfiConverterInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterMapInt64Int64.write(value.values, buf)
        FfiConverterInt64.write(value.sum, buf)
        FfiConverterInt64.write(value.count, buf)


class InternalConfiguration:

    def __init__(self, data_path, application_id, language_binding_name, upload_enabled, max_events, delay_ping_lifetime_io, app_build, use_core_mps, trim_data_to_registered_pings, log_level, rate_limit, enable_event_timestamps, experimentation_id):
        self.data_path = data_path
        self.application_id = application_id
        self.language_binding_name = language_binding_name
        self.upload_enabled = upload_enabled
        self.max_events = max_events
        self.delay_ping_lifetime_io = delay_ping_lifetime_io
        self.app_build = app_build
        self.use_core_mps = use_core_mps
        self.trim_data_to_registered_pings = trim_data_to_registered_pings
        self.log_level = log_level
        self.rate_limit = rate_limit
        self.enable_event_timestamps = enable_event_timestamps
        self.experimentation_id = experimentation_id

    def __str__(self):
        return "InternalConfiguration(data_path={}, application_id={}, language_binding_name={}, upload_enabled={}, max_events={}, delay_ping_lifetime_io={}, app_build={}, use_core_mps={}, trim_data_to_registered_pings={}, log_level={}, rate_limit={}, enable_event_timestamps={}, experimentation_id={})".format(self.data_path, self.application_id, self.language_binding_name, self.upload_enabled, self.max_events, self.delay_ping_lifetime_io, self.app_build, self.use_core_mps, self.trim_data_to_registered_pings, self.log_level, self.rate_limit, self.enable_event_timestamps, self.experimentation_id)

    def __eq__(self, other):
        if self.data_path != other.data_path:
            return False
        if self.application_id != other.application_id:
            return False
        if self.language_binding_name != other.language_binding_name:
            return False
        if self.upload_enabled != other.upload_enabled:
            return False
        if self.max_events != other.max_events:
            return False
        if self.delay_ping_lifetime_io != other.delay_ping_lifetime_io:
            return False
        if self.app_build != other.app_build:
            return False
        if self.use_core_mps != other.use_core_mps:
            return False
        if self.trim_data_to_registered_pings != other.trim_data_to_registered_pings:
            return False
        if self.log_level != other.log_level:
            return False
        if self.rate_limit != other.rate_limit:
            return False
        if self.enable_event_timestamps != other.enable_event_timestamps:
            return False
        if self.experimentation_id != other.experimentation_id:
            return False
        return True

class FfiConverterTypeInternalConfiguration(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InternalConfiguration(
            data_path=FfiConverterString.read(buf),
            application_id=FfiConverterString.read(buf),
            language_binding_name=FfiConverterString.read(buf),
            upload_enabled=FfiConverterBool.read(buf),
            max_events=FfiConverterOptionalUInt32.read(buf),
            delay_ping_lifetime_io=FfiConverterBool.read(buf),
            app_build=FfiConverterString.read(buf),
            use_core_mps=FfiConverterBool.read(buf),
            trim_data_to_registered_pings=FfiConverterBool.read(buf),
            log_level=FfiConverterOptionalTypeLevelFilter.read(buf),
            rate_limit=FfiConverterOptionalTypePingRateLimit.read(buf),
            enable_event_timestamps=FfiConverterBool.read(buf),
            experimentation_id=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.data_path, buf)
        FfiConverterString.write(value.application_id, buf)
        FfiConverterString.write(value.language_binding_name, buf)
        FfiConverterBool.write(value.upload_enabled, buf)
        FfiConverterOptionalUInt32.write(value.max_events, buf)
        FfiConverterBool.write(value.delay_ping_lifetime_io, buf)
        FfiConverterString.write(value.app_build, buf)
        FfiConverterBool.write(value.use_core_mps, buf)
        FfiConverterBool.write(value.trim_data_to_registered_pings, buf)
        FfiConverterOptionalTypeLevelFilter.write(value.log_level, buf)
        FfiConverterOptionalTypePingRateLimit.write(value.rate_limit, buf)
        FfiConverterBool.write(value.enable_event_timestamps, buf)
        FfiConverterOptionalString.write(value.experimentation_id, buf)


class PingRateLimit:

    def __init__(self, seconds_per_interval, pings_per_interval):
        self.seconds_per_interval = seconds_per_interval
        self.pings_per_interval = pings_per_interval

    def __str__(self):
        return "PingRateLimit(seconds_per_interval={}, pings_per_interval={})".format(self.seconds_per_interval, self.pings_per_interval)

    def __eq__(self, other):
        if self.seconds_per_interval != other.seconds_per_interval:
            return False
        if self.pings_per_interval != other.pings_per_interval:
            return False
        return True

class FfiConverterTypePingRateLimit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRateLimit(
            seconds_per_interval=FfiConverterUInt64.read(buf),
            pings_per_interval=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.seconds_per_interval, buf)
        FfiConverterUInt32.write(value.pings_per_interval, buf)


class PingRequest:

    def __init__(self, document_id, path, body, headers):
        self.document_id = document_id
        self.path = path
        self.body = body
        self.headers = headers

    def __str__(self):
        return "PingRequest(document_id={}, path={}, body={}, headers={})".format(self.document_id, self.path, self.body, self.headers)

    def __eq__(self, other):
        if self.document_id != other.document_id:
            return False
        if self.path != other.path:
            return False
        if self.body != other.body:
            return False
        if self.headers != other.headers:
            return False
        return True

class FfiConverterTypePingRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRequest(
            document_id=FfiConverterString.read(buf),
            path=FfiConverterString.read(buf),
            body=FfiConverterSequenceUInt8.read(buf),
            headers=FfiConverterMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.document_id, buf)
        FfiConverterString.write(value.path, buf)
        FfiConverterSequenceUInt8.write(value.body, buf)
        FfiConverterMapStringString.write(value.headers, buf)


class Rate:

    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return "Rate(numerator={}, denominator={})".format(self.numerator, self.denominator)

    def __eq__(self, other):
        if self.numerator != other.numerator:
            return False
        if self.denominator != other.denominator:
            return False
        return True

class FfiConverterTypeRate(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            numerator=FfiConverterInt32.read(buf),
            denominator=FfiConverterInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterInt32.write(value.numerator, buf)
        FfiConverterInt32.write(value.denominator, buf)


class RecordedEvent:

    def __init__(self, timestamp, category, name, extra):
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra

    def __str__(self):
        return "RecordedEvent(timestamp={}, category={}, name={}, extra={})".format(self.timestamp, self.category, self.name, self.extra)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.extra != other.extra:
            return False
        return True

class FfiConverterTypeRecordedEvent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedEvent(
            timestamp=FfiConverterUInt64.read(buf),
            category=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            extra=FfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.timestamp, buf)
        FfiConverterString.write(value.category, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterOptionalMapStringString.write(value.extra, buf)


class RecordedExperiment:

    def __init__(self, branch, extra):
        self.branch = branch
        self.extra = extra

    def __str__(self):
        return "RecordedExperiment(branch={}, extra={})".format(self.branch, self.extra)

    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.extra != other.extra:
            return False
        return True

class FfiConverterTypeRecordedExperiment(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedExperiment(
            branch=FfiConverterString.read(buf),
            extra=FfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.branch, buf)
        FfiConverterOptionalMapStringString.write(value.extra, buf)


class TimerId:

    def __init__(self, id):
        self.id = id

    def __str__(self):
        return "TimerId(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class FfiConverterTypeTimerId(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TimerId(
            id=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.id, buf)


# CallbackError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CallbackError(Exception):
    pass

UniFFITempCallbackError = CallbackError

class CallbackError:  # type: ignore
    class UnexpectedError(UniFFITempCallbackError):
        def __repr__(self):
            return "CallbackError.UnexpectedError({})".format(repr(str(self)))
    UniFFITempCallbackError.UnexpectedError = UnexpectedError  # type: ignore

CallbackError = UniFFITempCallbackError  # type: ignore
del UniFFITempCallbackError


class FfiConverterTypeCallbackError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CallbackError.UnexpectedError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, CallbackError.UnexpectedError):
            buf.writeI32(1)





class ErrorType(enum.Enum):
    INVALID_VALUE = 1
    INVALID_LABEL = 2
    INVALID_STATE = 3
    INVALID_OVERFLOW = 4
    


class FfiConverterTypeErrorType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ErrorType.INVALID_VALUE
        if variant == 2:
            return ErrorType.INVALID_LABEL
        if variant == 3:
            return ErrorType.INVALID_STATE
        if variant == 4:
            return ErrorType.INVALID_OVERFLOW
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ErrorType.INVALID_VALUE:
            buf.writeI32(1)
        if value == ErrorType.INVALID_LABEL:
            buf.writeI32(2)
        if value == ErrorType.INVALID_STATE:
            buf.writeI32(3)
        if value == ErrorType.INVALID_OVERFLOW:
            buf.writeI32(4)






class HistogramType(enum.Enum):
    LINEAR = 1
    EXPONENTIAL = 2
    


class FfiConverterTypeHistogramType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return HistogramType.LINEAR
        if variant == 2:
            return HistogramType.EXPONENTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == HistogramType.LINEAR:
            buf.writeI32(1)
        if value == HistogramType.EXPONENTIAL:
            buf.writeI32(2)






class LevelFilter(enum.Enum):
    OFF = 1
    ERROR = 2
    WARN = 3
    INFO = 4
    DEBUG = 5
    TRACE = 6
    


class FfiConverterTypeLevelFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LevelFilter.OFF
        if variant == 2:
            return LevelFilter.ERROR
        if variant == 3:
            return LevelFilter.WARN
        if variant == 4:
            return LevelFilter.INFO
        if variant == 5:
            return LevelFilter.DEBUG
        if variant == 6:
            return LevelFilter.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LevelFilter.OFF:
            buf.writeI32(1)
        if value == LevelFilter.ERROR:
            buf.writeI32(2)
        if value == LevelFilter.WARN:
            buf.writeI32(3)
        if value == LevelFilter.INFO:
            buf.writeI32(4)
        if value == LevelFilter.DEBUG:
            buf.writeI32(5)
        if value == LevelFilter.TRACE:
            buf.writeI32(6)






class Lifetime(enum.Enum):
    PING = 1
    APPLICATION = 2
    USER = 3
    


class FfiConverterTypeLifetime(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Lifetime.PING
        if variant == 2:
            return Lifetime.APPLICATION
        if variant == 3:
            return Lifetime.USER
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Lifetime.PING:
            buf.writeI32(1)
        if value == Lifetime.APPLICATION:
            buf.writeI32(2)
        if value == Lifetime.USER:
            buf.writeI32(3)






class MemoryUnit(enum.Enum):
    BYTE = 1
    KILOBYTE = 2
    MEGABYTE = 3
    GIGABYTE = 4
    


class FfiConverterTypeMemoryUnit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return MemoryUnit.BYTE
        if variant == 2:
            return MemoryUnit.KILOBYTE
        if variant == 3:
            return MemoryUnit.MEGABYTE
        if variant == 4:
            return MemoryUnit.GIGABYTE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == MemoryUnit.BYTE:
            buf.writeI32(1)
        if value == MemoryUnit.KILOBYTE:
            buf.writeI32(2)
        if value == MemoryUnit.MEGABYTE:
            buf.writeI32(3)
        if value == MemoryUnit.GIGABYTE:
            buf.writeI32(4)






class PingUploadTask:
    def __init__(self):
        raise RuntimeError("PingUploadTask cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UPLOAD:
        def __init__(self,request):
            
            self.request = request
            

        def __str__(self):
            return "PingUploadTask.UPLOAD(request={})".format(self.request)

        def __eq__(self, other):
            if not other.is_upload():
                return False
            if self.request != other.request:
                return False
            return True
    class WAIT:
        def __init__(self,time):
            
            self.time = time
            

        def __str__(self):
            return "PingUploadTask.WAIT(time={})".format(self.time)

        def __eq__(self, other):
            if not other.is_wait():
                return False
            if self.time != other.time:
                return False
            return True
    class DONE:
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "PingUploadTask.DONE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_done():
                return False
            if self.unused != other.unused:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_upload(self) -> bool:
        return isinstance(self, PingUploadTask.UPLOAD)
    def is_wait(self) -> bool:
        return isinstance(self, PingUploadTask.WAIT)
    def is_done(self) -> bool:
        return isinstance(self, PingUploadTask.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PingUploadTask.UPLOAD = type("PingUploadTask.UPLOAD", (PingUploadTask.UPLOAD, PingUploadTask,), {})  # type: ignore
PingUploadTask.WAIT = type("PingUploadTask.WAIT", (PingUploadTask.WAIT, PingUploadTask,), {})  # type: ignore
PingUploadTask.DONE = type("PingUploadTask.DONE", (PingUploadTask.DONE, PingUploadTask,), {})  # type: ignore




class FfiConverterTypePingUploadTask(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PingUploadTask.UPLOAD(
                FfiConverterTypePingRequest.read(buf),
            )
        if variant == 2:
            return PingUploadTask.WAIT(
                FfiConverterUInt64.read(buf),
            )
        if variant == 3:
            return PingUploadTask.DONE(
                FfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_upload():
            buf.writeI32(1)
            FfiConverterTypePingRequest.write(value.request, buf)
        if value.is_wait():
            buf.writeI32(2)
            FfiConverterUInt64.write(value.time, buf)
        if value.is_done():
            buf.writeI32(3)
            FfiConverterInt8.write(value.unused, buf)






class TimeUnit(enum.Enum):
    NANOSECOND = 1
    MICROSECOND = 2
    MILLISECOND = 3
    SECOND = 4
    MINUTE = 5
    HOUR = 6
    DAY = 7
    


class FfiConverterTypeTimeUnit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TimeUnit.NANOSECOND
        if variant == 2:
            return TimeUnit.MICROSECOND
        if variant == 3:
            return TimeUnit.MILLISECOND
        if variant == 4:
            return TimeUnit.SECOND
        if variant == 5:
            return TimeUnit.MINUTE
        if variant == 6:
            return TimeUnit.HOUR
        if variant == 7:
            return TimeUnit.DAY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TimeUnit.NANOSECOND:
            buf.writeI32(1)
        if value == TimeUnit.MICROSECOND:
            buf.writeI32(2)
        if value == TimeUnit.MILLISECOND:
            buf.writeI32(3)
        if value == TimeUnit.SECOND:
            buf.writeI32(4)
        if value == TimeUnit.MINUTE:
            buf.writeI32(5)
        if value == TimeUnit.HOUR:
            buf.writeI32(6)
        if value == TimeUnit.DAY:
            buf.writeI32(7)






class UploadResult:
    def __init__(self):
        raise RuntimeError("UploadResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RECOVERABLE_FAILURE:
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.RECOVERABLE_FAILURE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_recoverable_failure():
                return False
            if self.unused != other.unused:
                return False
            return True
    class UNRECOVERABLE_FAILURE:
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.UNRECOVERABLE_FAILURE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_unrecoverable_failure():
                return False
            if self.unused != other.unused:
                return False
            return True
    class HTTP_STATUS:
        def __init__(self,code):
            
            self.code = code
            

        def __str__(self):
            return "UploadResult.HTTP_STATUS(code={})".format(self.code)

        def __eq__(self, other):
            if not other.is_http_status():
                return False
            if self.code != other.code:
                return False
            return True
    class DONE:
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.DONE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_done():
                return False
            if self.unused != other.unused:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_recoverable_failure(self) -> bool:
        return isinstance(self, UploadResult.RECOVERABLE_FAILURE)
    def is_unrecoverable_failure(self) -> bool:
        return isinstance(self, UploadResult.UNRECOVERABLE_FAILURE)
    def is_http_status(self) -> bool:
        return isinstance(self, UploadResult.HTTP_STATUS)
    def is_done(self) -> bool:
        return isinstance(self, UploadResult.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UploadResult.RECOVERABLE_FAILURE = type("UploadResult.RECOVERABLE_FAILURE", (UploadResult.RECOVERABLE_FAILURE, UploadResult,), {})  # type: ignore
UploadResult.UNRECOVERABLE_FAILURE = type("UploadResult.UNRECOVERABLE_FAILURE", (UploadResult.UNRECOVERABLE_FAILURE, UploadResult,), {})  # type: ignore
UploadResult.HTTP_STATUS = type("UploadResult.HTTP_STATUS", (UploadResult.HTTP_STATUS, UploadResult,), {})  # type: ignore
UploadResult.DONE = type("UploadResult.DONE", (UploadResult.DONE, UploadResult,), {})  # type: ignore




class FfiConverterTypeUploadResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return UploadResult.RECOVERABLE_FAILURE(
                FfiConverterInt8.read(buf),
            )
        if variant == 2:
            return UploadResult.UNRECOVERABLE_FAILURE(
                FfiConverterInt8.read(buf),
            )
        if variant == 3:
            return UploadResult.HTTP_STATUS(
                FfiConverterInt32.read(buf),
            )
        if variant == 4:
            return UploadResult.DONE(
                FfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_recoverable_failure():
            buf.writeI32(1)
            FfiConverterInt8.write(value.unused, buf)
        if value.is_unrecoverable_failure():
            buf.writeI32(2)
            FfiConverterInt8.write(value.unused, buf)
        if value.is_http_status():
            buf.writeI32(3)
            FfiConverterInt32.write(value.code, buf)
        if value.is_done():
            buf.writeI32(4)
            FfiConverterInt8.write(value.unused, buf)






class UploadTaskAction(enum.Enum):
    NEXT = 1
    END = 2
    


class FfiConverterTypeUploadTaskAction(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return UploadTaskAction.NEXT
        if variant == 2:
            return UploadTaskAction.END
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == UploadTaskAction.NEXT:
            buf.writeI32(1)
        if value == UploadTaskAction.END:
            buf.writeI32(2)




import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0
# Return codes for callback calls
UNIFFI_CALLBACK_SUCCESS = 0
UNIFFI_CALLBACK_ERROR = 1
UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))

# Declaration and FfiConverters for OnGleanEvents Callback Interface

class OnGleanEvents:
    def initialize_finished(self, ):
        raise NotImplementedError

    def trigger_upload(self, ):
        raise NotImplementedError

    def start_metrics_ping_scheduler(self, ):
        raise NotImplementedError

    def cancel_uploads(self, ):
        raise NotImplementedError

    def shutdown(self, ):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceOnGleanEvents(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_initialize_finished(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.initialize_finished()

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_trigger_upload(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.trigger_upload()

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except CallbackError as e:
            # Catch errors declared in the UDL file
            with RustBuffer.allocWithBuilder() as builder:
                FfiConverterTypeCallbackError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return UNIFFI_CALLBACK_ERROR

    
    def invoke_start_metrics_ping_scheduler(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.start_metrics_ping_scheduler()

        def makeCallAndHandleReturn():
            rval = makeCall()
            with RustBuffer.allocWithBuilder() as builder:
                FfiConverterBool.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_cancel_uploads(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.cancel_uploads()

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except CallbackError as e:
            # Catch errors declared in the UDL file
            with RustBuffer.allocWithBuilder() as builder:
                FfiConverterTypeCallbackError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return UNIFFI_CALLBACK_ERROR

    
    def invoke_shutdown(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.shutdown()

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except CallbackError as e:
            # Catch errors declared in the UDL file
            with RustBuffer.allocWithBuilder() as builder:
                FfiConverterTypeCallbackError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return UNIFFI_CALLBACK_ERROR

    

    cb = FfiConverterCallbackInterfaceOnGleanEvents.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceOnGleanEvents.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_initialize_finished(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 2:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_trigger_upload(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 3:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_start_metrics_ping_scheduler(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 4:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_cancel_uploads(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 5:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_shutdown(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceOnGleanEvents = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceOnGleanEvents)
rust_call(lambda err: _UniFFILib.uniffi_glean_fn_init_callback_ongleanevents(foreignCallbackCallbackInterfaceOnGleanEvents, err))

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
FfiConverterCallbackInterfaceOnGleanEvents = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceOnGleanEvents)



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalBool(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeDatetime(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDatetime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDatetime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeDistributionData(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDistributionData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDistributionData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePingRateLimit(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePingRateLimit.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePingRateLimit.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeRate(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRate.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRate.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeRecordedExperiment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRecordedExperiment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRecordedExperiment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLevelFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLevelFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLevelFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeRecordedEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeRecordedEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeRecordedEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeCowString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeCowString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeCowString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalMapStringString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterInt64.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCommonMetricData(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCommonMetricData.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCommonMetricData.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRecordedEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRecordedEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRecordedEvent.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCowString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCowString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCowString.read(buf) for i in range(count)
        ]



class FfiConverterMapInt64Int64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterInt64.write(key, buf)
            FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterInt64.read(buf)
            val = FfiConverterInt64.read(buf)
            d[key] = val
        return d



class FfiConverterMapStringString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterString.read(buf)
            d[key] = val
        return d


# Type alias
CowString = str

class FfiConverterTypeCowString:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)

def glean_enable_logging():
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_enable_logging,)


def glean_enable_logging_to_fd(fd: "int"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_enable_logging_to_fd,
        FfiConverterUInt64.lower(fd))


def glean_initialize(cfg: "InternalConfiguration",client_info: "ClientInfoMetrics",callbacks: "OnGleanEvents"):
    
    
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_initialize,
        FfiConverterTypeInternalConfiguration.lower(cfg),
        FfiConverterTypeClientInfoMetrics.lower(client_info),
        FfiConverterCallbackInterfaceOnGleanEvents.lower(callbacks))


def glean_shutdown():
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_shutdown,)


def glean_initialize_for_subprocess(cfg: "InternalConfiguration"):
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_initialize_for_subprocess,
        FfiConverterTypeInternalConfiguration.lower(cfg)))


def glean_set_upload_enabled(enabled: "bool"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_upload_enabled,
        FfiConverterBool.lower(enabled))


def glean_set_experiment_active(experiment_id: "str",branch: "str",extra: "dict"):
    
    
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_active,
        FfiConverterString.lower(experiment_id),
        FfiConverterString.lower(branch),
        FfiConverterMapStringString.lower(extra))


def glean_set_experiment_inactive(experiment_id: "str"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_experiment_inactive,
        FfiConverterString.lower(experiment_id))


def glean_test_get_experiment_data(experiment_id: "str"):
    
    return FfiConverterOptionalTypeRecordedExperiment.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_test_get_experiment_data,
        FfiConverterString.lower(experiment_id)))


def glean_test_get_experimentation_id():
    return FfiConverterOptionalString.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_test_get_experimentation_id,))


def glean_set_metrics_enabled_config(json: "str"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_metrics_enabled_config,
        FfiConverterString.lower(json))


def glean_set_debug_view_tag(tag: "str"):
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_debug_view_tag,
        FfiConverterString.lower(tag)))


def glean_set_source_tags(tags: "typing.List[str]"):
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_source_tags,
        FfiConverterSequenceString.lower(tags)))


def glean_set_log_pings(value: "bool"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_log_pings,
        FfiConverterBool.lower(value))


def glean_handle_client_active():
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_handle_client_active,)


def glean_handle_client_inactive():
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_handle_client_inactive,)


def glean_submit_ping_by_name(ping_name: "str",reason: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
    
    if reason is DEFAULT:
        reason = None
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name,
        FfiConverterString.lower(ping_name),
        FfiConverterOptionalString.lower(reason))


def glean_submit_ping_by_name_sync(ping_name: "str",reason: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
    
    if reason is DEFAULT:
        reason = None
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_submit_ping_by_name_sync,
        FfiConverterString.lower(ping_name),
        FfiConverterOptionalString.lower(reason)))


def glean_set_test_mode(enabled: "bool"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_test_mode,
        FfiConverterBool.lower(enabled))


def glean_test_destroy_glean(clear_stores: "bool",data_path: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
    
    if data_path is DEFAULT:
        data_path = None
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_test_destroy_glean,
        FfiConverterBool.lower(clear_stores),
        FfiConverterOptionalString.lower(data_path))


def glean_set_dirty_flag(flag: "bool"):
    
    rust_call(_UniFFILib.uniffi_glean_fn_func_glean_set_dirty_flag,
        FfiConverterBool.lower(flag))


def glean_get_upload_task():
    return FfiConverterTypePingUploadTask.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_get_upload_task,))


def glean_process_ping_upload_response(uuid: "str",result: "UploadResult"):
    
    
    return FfiConverterTypeUploadTaskAction.lift(rust_call(_UniFFILib.uniffi_glean_fn_func_glean_process_ping_upload_response,
        FfiConverterString.lower(uuid),
        FfiConverterTypeUploadResult.lower(result)))


__all__ = [
    "InternalError",
    "CallbackError",
    "ErrorType",
    "HistogramType",
    "LevelFilter",
    "Lifetime",
    "MemoryUnit",
    "PingUploadTask",
    "TimeUnit",
    "UploadResult",
    "UploadTaskAction",
    "ClientInfoMetrics",
    "CommonMetricData",
    "Datetime",
    "DistributionData",
    "InternalConfiguration",
    "PingRateLimit",
    "PingRequest",
    "Rate",
    "RecordedEvent",
    "RecordedExperiment",
    "TimerId",
    "glean_enable_logging",
    "glean_enable_logging_to_fd",
    "glean_initialize",
    "glean_shutdown",
    "glean_initialize_for_subprocess",
    "glean_set_upload_enabled",
    "glean_set_experiment_active",
    "glean_set_experiment_inactive",
    "glean_test_get_experiment_data",
    "glean_test_get_experimentation_id",
    "glean_set_metrics_enabled_config",
    "glean_set_debug_view_tag",
    "glean_set_source_tags",
    "glean_set_log_pings",
    "glean_handle_client_active",
    "glean_handle_client_inactive",
    "glean_submit_ping_by_name",
    "glean_submit_ping_by_name_sync",
    "glean_set_test_mode",
    "glean_test_destroy_glean",
    "glean_set_dirty_flag",
    "glean_get_upload_task",
    "glean_process_ping_upload_response",
    "PingType",
    "CounterMetric",
    "TimespanMetric",
    "BooleanMetric",
    "StringMetric",
    "LabeledCounter",
    "LabeledBoolean",
    "LabeledString",
    "StringListMetric",
    "UrlMetric",
    "UuidMetric",
    "QuantityMetric",
    "TimingDistributionMetric",
    "MemoryDistributionMetric",
    "CustomDistributionMetric",
    "DatetimeMetric",
    "EventMetric",
    "RateMetric",
    "DenominatorMetric",
    "NumeratorMetric",
    "TextMetric",
    "OnGleanEvents",
]

