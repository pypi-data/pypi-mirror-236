# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import collections

from sys import version_info as _version_info
if _version_info < (3, 7, 0):
    raise RuntimeError("Python 3.7 or later required")

from . import _ITKCommonPython


from . import _ITKBridgeNumPyPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkPyBufferPython
else:
    import _itkPyBufferPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkPyBufferPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkPyBufferPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import collections.abc
import itk.itkImagePython
import itk.itkImageRegionPython
import itk.itkIndexPython
import itk.itkSizePython
import itk.pyBasePython
import itk.itkOffsetPython
import itk.ITKCommonBasePython
import itk.itkMatrixPython
import itk.itkCovariantVectorPython
import itk.itkFixedArrayPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.vnl_matrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkRGBPixelPython
import itk.itkRGBAPixelPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython


import numpy as np
class NDArrayITKBase(np.ndarray):
  """A numpy array that provides a view on the data associated with an optional itk "base" object."""

  def __new__(cls, input_array, itk_base=None):
      obj = np.asarray(input_array).view(cls)
      obj.itk_base = itk_base
      return obj

  def __array_finalize__(self, obj):
      if obj is None: return
      self.itk_base = getattr(obj, 'itk_base', None)

try:
    from distributed.protocol import dask_serialize, dask_deserialize
    from typing import Dict, List, Tuple
except (ImportError, RuntimeError):
    pass
else:
    @dask_serialize.register(NDArrayITKBase)
    def serialize(ndarray_itk_base: NDArrayITKBase) -> Tuple[Dict, List[bytes]]:
        dumps = dask_serialize.dispatch(np.ndarray)
        return dumps(ndarray_itk_base)

    @dask_deserialize.register(NDArrayITKBase)
    def deserialize(header: Dict, frames: List[bytes]) -> NDArrayITKBase:
        loads = dask_deserialize.dispatch(np.ndarray)
        return NDArrayITKBase(loads(header, frames))

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "ULL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "SLL":np.int64,
               "F":np.float32,
               "D":np.float64,
               "PF2":np.float32,
               "PF3":np.float32,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

class itkPyBufferICVD22(object):
    r"""Proxy of C++ itkPyBufferICVD22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD22
        __init__(self, arg0) -> itkPyBufferICVD22

        Parameters
        ----------
        arg0: itkPyBufferICVD22 const &

        """
        _itkPyBufferPython.itkPyBufferICVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD22_swigregister(itkPyBufferICVD22)
itkPyBufferICVD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage
itkPyBufferICVD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray

class itkPyBufferICVD23(object):
    r"""Proxy of C++ itkPyBufferICVD23 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD23
        __init__(self, arg0) -> itkPyBufferICVD23

        Parameters
        ----------
        arg0: itkPyBufferICVD23 const &

        """
        _itkPyBufferPython.itkPyBufferICVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD23._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD23._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD23._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD23.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD23_swigregister(itkPyBufferICVD23)
itkPyBufferICVD23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage
itkPyBufferICVD23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray

class itkPyBufferICVD24(object):
    r"""Proxy of C++ itkPyBufferICVD24 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD24__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD24__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD24
        __init__(self, arg0) -> itkPyBufferICVD24

        Parameters
        ----------
        arg0: itkPyBufferICVD24 const &

        """
        _itkPyBufferPython.itkPyBufferICVD24_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD24(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD24


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD24._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD24.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD24._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD24._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD24._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD24.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD24 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD24_swigregister(itkPyBufferICVD24)
itkPyBufferICVD24__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD24__GetArrayViewFromImage
itkPyBufferICVD24__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD24__GetImageViewFromArray

class itkPyBufferICVD32(object):
    r"""Proxy of C++ itkPyBufferICVD32 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD32
        __init__(self, arg0) -> itkPyBufferICVD32

        Parameters
        ----------
        arg0: itkPyBufferICVD32 const &

        """
        _itkPyBufferPython.itkPyBufferICVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD32._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD32._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD32._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD32.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD32_swigregister(itkPyBufferICVD32)
itkPyBufferICVD32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage
itkPyBufferICVD32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray

class itkPyBufferICVD33(object):
    r"""Proxy of C++ itkPyBufferICVD33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD33
        __init__(self, arg0) -> itkPyBufferICVD33

        Parameters
        ----------
        arg0: itkPyBufferICVD33 const &

        """
        _itkPyBufferPython.itkPyBufferICVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD33_swigregister(itkPyBufferICVD33)
itkPyBufferICVD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage
itkPyBufferICVD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray

class itkPyBufferICVD34(object):
    r"""Proxy of C++ itkPyBufferICVD34 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD34__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD34__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD34
        __init__(self, arg0) -> itkPyBufferICVD34

        Parameters
        ----------
        arg0: itkPyBufferICVD34 const &

        """
        _itkPyBufferPython.itkPyBufferICVD34_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD34(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD34


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD34._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD34.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD34._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD34._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD34._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD34.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD34 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD34_swigregister(itkPyBufferICVD34)
itkPyBufferICVD34__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD34__GetArrayViewFromImage
itkPyBufferICVD34__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD34__GetImageViewFromArray

class itkPyBufferICVD42(object):
    r"""Proxy of C++ itkPyBufferICVD42 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD42
        __init__(self, arg0) -> itkPyBufferICVD42

        Parameters
        ----------
        arg0: itkPyBufferICVD42 const &

        """
        _itkPyBufferPython.itkPyBufferICVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD42._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD42._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD42._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD42.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD42_swigregister(itkPyBufferICVD42)
itkPyBufferICVD42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage
itkPyBufferICVD42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray

class itkPyBufferICVD43(object):
    r"""Proxy of C++ itkPyBufferICVD43 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD43
        __init__(self, arg0) -> itkPyBufferICVD43

        Parameters
        ----------
        arg0: itkPyBufferICVD43 const &

        """
        _itkPyBufferPython.itkPyBufferICVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD43._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD43._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD43._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD43.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD43_swigregister(itkPyBufferICVD43)
itkPyBufferICVD43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage
itkPyBufferICVD43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray

class itkPyBufferICVD44(object):
    r"""Proxy of C++ itkPyBufferICVD44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVD44
        __init__(self, arg0) -> itkPyBufferICVD44

        Parameters
        ----------
        arg0: itkPyBufferICVD44 const &

        """
        _itkPyBufferPython.itkPyBufferICVD44_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVD44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVD44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVD44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD44_swigregister(itkPyBufferICVD44)
itkPyBufferICVD44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD44__GetArrayViewFromImage
itkPyBufferICVD44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD44__GetImageViewFromArray

class itkPyBufferICVF22(object):
    r"""Proxy of C++ itkPyBufferICVF22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF22
        __init__(self, arg0) -> itkPyBufferICVF22

        Parameters
        ----------
        arg0: itkPyBufferICVF22 const &

        """
        _itkPyBufferPython.itkPyBufferICVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF22_swigregister(itkPyBufferICVF22)
itkPyBufferICVF22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage
itkPyBufferICVF22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray

class itkPyBufferICVF23(object):
    r"""Proxy of C++ itkPyBufferICVF23 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF23
        __init__(self, arg0) -> itkPyBufferICVF23

        Parameters
        ----------
        arg0: itkPyBufferICVF23 const &

        """
        _itkPyBufferPython.itkPyBufferICVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF23._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF23._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF23._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF23.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF23_swigregister(itkPyBufferICVF23)
itkPyBufferICVF23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage
itkPyBufferICVF23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray

class itkPyBufferICVF24(object):
    r"""Proxy of C++ itkPyBufferICVF24 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF24__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF24__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF24
        __init__(self, arg0) -> itkPyBufferICVF24

        Parameters
        ----------
        arg0: itkPyBufferICVF24 const &

        """
        _itkPyBufferPython.itkPyBufferICVF24_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF24(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF24


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF24._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF24.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF24._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF24._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF24._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF24.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF24 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF24_swigregister(itkPyBufferICVF24)
itkPyBufferICVF24__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF24__GetArrayViewFromImage
itkPyBufferICVF24__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF24__GetImageViewFromArray

class itkPyBufferICVF32(object):
    r"""Proxy of C++ itkPyBufferICVF32 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF32
        __init__(self, arg0) -> itkPyBufferICVF32

        Parameters
        ----------
        arg0: itkPyBufferICVF32 const &

        """
        _itkPyBufferPython.itkPyBufferICVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF32._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF32._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF32._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF32.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF32_swigregister(itkPyBufferICVF32)
itkPyBufferICVF32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage
itkPyBufferICVF32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray

class itkPyBufferICVF33(object):
    r"""Proxy of C++ itkPyBufferICVF33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF33
        __init__(self, arg0) -> itkPyBufferICVF33

        Parameters
        ----------
        arg0: itkPyBufferICVF33 const &

        """
        _itkPyBufferPython.itkPyBufferICVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF33_swigregister(itkPyBufferICVF33)
itkPyBufferICVF33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage
itkPyBufferICVF33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray

class itkPyBufferICVF34(object):
    r"""Proxy of C++ itkPyBufferICVF34 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF34__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF34__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF34
        __init__(self, arg0) -> itkPyBufferICVF34

        Parameters
        ----------
        arg0: itkPyBufferICVF34 const &

        """
        _itkPyBufferPython.itkPyBufferICVF34_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF34(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF34


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF34._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF34.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF34._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF34._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF34._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF34.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF34 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF34_swigregister(itkPyBufferICVF34)
itkPyBufferICVF34__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF34__GetArrayViewFromImage
itkPyBufferICVF34__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF34__GetImageViewFromArray

class itkPyBufferICVF42(object):
    r"""Proxy of C++ itkPyBufferICVF42 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF42
        __init__(self, arg0) -> itkPyBufferICVF42

        Parameters
        ----------
        arg0: itkPyBufferICVF42 const &

        """
        _itkPyBufferPython.itkPyBufferICVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF42._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF42._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF42._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF42.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF42_swigregister(itkPyBufferICVF42)
itkPyBufferICVF42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage
itkPyBufferICVF42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray

class itkPyBufferICVF43(object):
    r"""Proxy of C++ itkPyBufferICVF43 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF43
        __init__(self, arg0) -> itkPyBufferICVF43

        Parameters
        ----------
        arg0: itkPyBufferICVF43 const &

        """
        _itkPyBufferPython.itkPyBufferICVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF43._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF43._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF43._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF43.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF43_swigregister(itkPyBufferICVF43)
itkPyBufferICVF43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage
itkPyBufferICVF43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray

class itkPyBufferICVF44(object):
    r"""Proxy of C++ itkPyBufferICVF44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF44
        __init__(self, arg0) -> itkPyBufferICVF44

        Parameters
        ----------
        arg0: itkPyBufferICVF44 const &

        """
        _itkPyBufferPython.itkPyBufferICVF44_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF44_swigregister(itkPyBufferICVF44)
itkPyBufferICVF44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF44__GetArrayViewFromImage
itkPyBufferICVF44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF44__GetImageViewFromArray

class itkPyBufferID2(object):
    r"""Proxy of C++ itkPyBufferID2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferID2
        __init__(self, arg0) -> itkPyBufferID2

        Parameters
        ----------
        arg0: itkPyBufferID2 const &

        """
        _itkPyBufferPython.itkPyBufferID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferID2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferID2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferID2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferID2_swigregister(itkPyBufferID2)
itkPyBufferID2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage
itkPyBufferID2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray

class itkPyBufferID3(object):
    r"""Proxy of C++ itkPyBufferID3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferID3
        __init__(self, arg0) -> itkPyBufferID3

        Parameters
        ----------
        arg0: itkPyBufferID3 const &

        """
        _itkPyBufferPython.itkPyBufferID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferID3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferID3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferID3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferID3_swigregister(itkPyBufferID3)
itkPyBufferID3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage
itkPyBufferID3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray

class itkPyBufferID4(object):
    r"""Proxy of C++ itkPyBufferID4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferID4
        __init__(self, arg0) -> itkPyBufferID4

        Parameters
        ----------
        arg0: itkPyBufferID4 const &

        """
        _itkPyBufferPython.itkPyBufferID4_swiginit(self, _itkPyBufferPython.new_itkPyBufferID4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferID4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferID4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferID4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferID4_swigregister(itkPyBufferID4)
itkPyBufferID4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferID4__GetArrayViewFromImage
itkPyBufferID4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferID4__GetImageViewFromArray

class itkPyBufferIF2(object):
    r"""Proxy of C++ itkPyBufferIF2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIF2
        __init__(self, arg0) -> itkPyBufferIF2

        Parameters
        ----------
        arg0: itkPyBufferIF2 const &

        """
        _itkPyBufferPython.itkPyBufferIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIF2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIF2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIF2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIF2_swigregister(itkPyBufferIF2)
itkPyBufferIF2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage
itkPyBufferIF2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray

class itkPyBufferIF3(object):
    r"""Proxy of C++ itkPyBufferIF3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIF3
        __init__(self, arg0) -> itkPyBufferIF3

        Parameters
        ----------
        arg0: itkPyBufferIF3 const &

        """
        _itkPyBufferPython.itkPyBufferIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIF3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIF3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIF3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIF3_swigregister(itkPyBufferIF3)
itkPyBufferIF3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage
itkPyBufferIF3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray

class itkPyBufferIF4(object):
    r"""Proxy of C++ itkPyBufferIF4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIF4
        __init__(self, arg0) -> itkPyBufferIF4

        Parameters
        ----------
        arg0: itkPyBufferIF4 const &

        """
        _itkPyBufferPython.itkPyBufferIF4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIF4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIF4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIF4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIF4_swigregister(itkPyBufferIF4)
itkPyBufferIF4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIF4__GetArrayViewFromImage
itkPyBufferIF4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIF4__GetImageViewFromArray

class itkPyBufferIRGBAUC2(object):
    r"""Proxy of C++ itkPyBufferIRGBAUC2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBAUC2
        __init__(self, arg0) -> itkPyBufferIRGBAUC2

        Parameters
        ----------
        arg0: itkPyBufferIRGBAUC2 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBAUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBAUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBAUC2_swigregister(itkPyBufferIRGBAUC2)
itkPyBufferIRGBAUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage
itkPyBufferIRGBAUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray

class itkPyBufferIRGBAUC3(object):
    r"""Proxy of C++ itkPyBufferIRGBAUC3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBAUC3
        __init__(self, arg0) -> itkPyBufferIRGBAUC3

        Parameters
        ----------
        arg0: itkPyBufferIRGBAUC3 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBAUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBAUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBAUC3_swigregister(itkPyBufferIRGBAUC3)
itkPyBufferIRGBAUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage
itkPyBufferIRGBAUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray

class itkPyBufferIRGBAUC4(object):
    r"""Proxy of C++ itkPyBufferIRGBAUC4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBAUC4
        __init__(self, arg0) -> itkPyBufferIRGBAUC4

        Parameters
        ----------
        arg0: itkPyBufferIRGBAUC4 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBAUC4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBAUC4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBAUC4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBAUC4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBAUC4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBAUC4_swigregister(itkPyBufferIRGBAUC4)
itkPyBufferIRGBAUC4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBAUC4__GetArrayViewFromImage
itkPyBufferIRGBAUC4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBAUC4__GetImageViewFromArray

class itkPyBufferIRGBUC2(object):
    r"""Proxy of C++ itkPyBufferIRGBUC2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBUC2
        __init__(self, arg0) -> itkPyBufferIRGBUC2

        Parameters
        ----------
        arg0: itkPyBufferIRGBUC2 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBUC2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBUC2_swigregister(itkPyBufferIRGBUC2)
itkPyBufferIRGBUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage
itkPyBufferIRGBUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray

class itkPyBufferIRGBUC3(object):
    r"""Proxy of C++ itkPyBufferIRGBUC3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBUC3
        __init__(self, arg0) -> itkPyBufferIRGBUC3

        Parameters
        ----------
        arg0: itkPyBufferIRGBUC3 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBUC3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBUC3_swigregister(itkPyBufferIRGBUC3)
itkPyBufferIRGBUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage
itkPyBufferIRGBUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray

class itkPyBufferIRGBUC4(object):
    r"""Proxy of C++ itkPyBufferIRGBUC4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIRGBUC4
        __init__(self, arg0) -> itkPyBufferIRGBUC4

        Parameters
        ----------
        arg0: itkPyBufferIRGBUC4 const &

        """
        _itkPyBufferPython.itkPyBufferIRGBUC4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIRGBUC4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIRGBUC4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIRGBUC4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBUC4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBUC4_swigregister(itkPyBufferIRGBUC4)
itkPyBufferIRGBUC4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBUC4__GetArrayViewFromImage
itkPyBufferIRGBUC4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBUC4__GetImageViewFromArray

class itkPyBufferISI2(object):
    r"""Proxy of C++ itkPyBufferISI2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISI2
        __init__(self, arg0) -> itkPyBufferISI2

        Parameters
        ----------
        arg0: itkPyBufferISI2 const &

        """
        _itkPyBufferPython.itkPyBufferISI2_swiginit(self, _itkPyBufferPython.new_itkPyBufferISI2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISI2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISI2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISI2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISI2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISI2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISI2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISI2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISI2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISI2_swigregister(itkPyBufferISI2)
itkPyBufferISI2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISI2__GetArrayViewFromImage
itkPyBufferISI2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISI2__GetImageViewFromArray

class itkPyBufferISI3(object):
    r"""Proxy of C++ itkPyBufferISI3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISI3
        __init__(self, arg0) -> itkPyBufferISI3

        Parameters
        ----------
        arg0: itkPyBufferISI3 const &

        """
        _itkPyBufferPython.itkPyBufferISI3_swiginit(self, _itkPyBufferPython.new_itkPyBufferISI3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISI3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISI3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISI3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISI3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISI3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISI3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISI3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISI3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISI3_swigregister(itkPyBufferISI3)
itkPyBufferISI3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISI3__GetArrayViewFromImage
itkPyBufferISI3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISI3__GetImageViewFromArray

class itkPyBufferISI4(object):
    r"""Proxy of C++ itkPyBufferISI4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISI4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISI4
        __init__(self, arg0) -> itkPyBufferISI4

        Parameters
        ----------
        arg0: itkPyBufferISI4 const &

        """
        _itkPyBufferPython.itkPyBufferISI4_swiginit(self, _itkPyBufferPython.new_itkPyBufferISI4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISI4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISI4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISI4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISI4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISI4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISI4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISI4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISI4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISI4_swigregister(itkPyBufferISI4)
itkPyBufferISI4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISI4__GetArrayViewFromImage
itkPyBufferISI4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISI4__GetImageViewFromArray

class itkPyBufferISS2(object):
    r"""Proxy of C++ itkPyBufferISS2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISS2
        __init__(self, arg0) -> itkPyBufferISS2

        Parameters
        ----------
        arg0: itkPyBufferISS2 const &

        """
        _itkPyBufferPython.itkPyBufferISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISS2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISS2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISS2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISS2_swigregister(itkPyBufferISS2)
itkPyBufferISS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage
itkPyBufferISS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray

class itkPyBufferISS3(object):
    r"""Proxy of C++ itkPyBufferISS3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISS3
        __init__(self, arg0) -> itkPyBufferISS3

        Parameters
        ----------
        arg0: itkPyBufferISS3 const &

        """
        _itkPyBufferPython.itkPyBufferISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISS3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISS3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISS3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISS3_swigregister(itkPyBufferISS3)
itkPyBufferISS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage
itkPyBufferISS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray

class itkPyBufferISS4(object):
    r"""Proxy of C++ itkPyBufferISS4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISS4
        __init__(self, arg0) -> itkPyBufferISS4

        Parameters
        ----------
        arg0: itkPyBufferISS4 const &

        """
        _itkPyBufferPython.itkPyBufferISS4_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISS4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISS4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISS4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISS4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISS4_swigregister(itkPyBufferISS4)
itkPyBufferISS4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISS4__GetArrayViewFromImage
itkPyBufferISS4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISS4__GetImageViewFromArray

class itkPyBufferISSRTD22(object):
    r"""Proxy of C++ itkPyBufferISSRTD22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTD22
        __init__(self, arg0) -> itkPyBufferISSRTD22

        Parameters
        ----------
        arg0: itkPyBufferISSRTD22 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTD22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTD22_swigregister(itkPyBufferISSRTD22)
itkPyBufferISSRTD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage
itkPyBufferISSRTD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray

class itkPyBufferISSRTD33(object):
    r"""Proxy of C++ itkPyBufferISSRTD33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTD33
        __init__(self, arg0) -> itkPyBufferISSRTD33

        Parameters
        ----------
        arg0: itkPyBufferISSRTD33 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTD33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTD33_swigregister(itkPyBufferISSRTD33)
itkPyBufferISSRTD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage
itkPyBufferISSRTD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray

class itkPyBufferISSRTD44(object):
    r"""Proxy of C++ itkPyBufferISSRTD44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTD44
        __init__(self, arg0) -> itkPyBufferISSRTD44

        Parameters
        ----------
        arg0: itkPyBufferISSRTD44 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTD44_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTD44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTD44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTD44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTD44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTD44_swigregister(itkPyBufferISSRTD44)
itkPyBufferISSRTD44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTD44__GetArrayViewFromImage
itkPyBufferISSRTD44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTD44__GetImageViewFromArray

class itkPyBufferISSRTF22(object):
    r"""Proxy of C++ itkPyBufferISSRTF22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTF22
        __init__(self, arg0) -> itkPyBufferISSRTF22

        Parameters
        ----------
        arg0: itkPyBufferISSRTF22 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTF22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTF22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTF22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTF22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTF22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTF22_swigregister(itkPyBufferISSRTF22)
itkPyBufferISSRTF22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTF22__GetArrayViewFromImage
itkPyBufferISSRTF22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTF22__GetImageViewFromArray

class itkPyBufferISSRTF33(object):
    r"""Proxy of C++ itkPyBufferISSRTF33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTF33
        __init__(self, arg0) -> itkPyBufferISSRTF33

        Parameters
        ----------
        arg0: itkPyBufferISSRTF33 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTF33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTF33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTF33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTF33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTF33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTF33_swigregister(itkPyBufferISSRTF33)
itkPyBufferISSRTF33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTF33__GetArrayViewFromImage
itkPyBufferISSRTF33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTF33__GetImageViewFromArray

class itkPyBufferISSRTF44(object):
    r"""Proxy of C++ itkPyBufferISSRTF44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTF44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferISSRTF44
        __init__(self, arg0) -> itkPyBufferISSRTF44

        Parameters
        ----------
        arg0: itkPyBufferISSRTF44 const &

        """
        _itkPyBufferPython.itkPyBufferISSRTF44_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTF44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTF44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTF44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTF44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferISSRTF44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferISSRTF44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferISSRTF44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTF44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTF44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTF44_swigregister(itkPyBufferISSRTF44)
itkPyBufferISSRTF44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTF44__GetArrayViewFromImage
itkPyBufferISSRTF44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTF44__GetImageViewFromArray

class itkPyBufferIUC2(object):
    r"""Proxy of C++ itkPyBufferIUC2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUC2
        __init__(self, arg0) -> itkPyBufferIUC2

        Parameters
        ----------
        arg0: itkPyBufferIUC2 const &

        """
        _itkPyBufferPython.itkPyBufferIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUC2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUC2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUC2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUC2_swigregister(itkPyBufferIUC2)
itkPyBufferIUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage
itkPyBufferIUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray

class itkPyBufferIUC3(object):
    r"""Proxy of C++ itkPyBufferIUC3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUC3
        __init__(self, arg0) -> itkPyBufferIUC3

        Parameters
        ----------
        arg0: itkPyBufferIUC3 const &

        """
        _itkPyBufferPython.itkPyBufferIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUC3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUC3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUC3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUC3_swigregister(itkPyBufferIUC3)
itkPyBufferIUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage
itkPyBufferIUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray

class itkPyBufferIUC4(object):
    r"""Proxy of C++ itkPyBufferIUC4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUC4
        __init__(self, arg0) -> itkPyBufferIUC4

        Parameters
        ----------
        arg0: itkPyBufferIUC4 const &

        """
        _itkPyBufferPython.itkPyBufferIUC4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUC4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUC4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUC4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUC4_swigregister(itkPyBufferIUC4)
itkPyBufferIUC4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUC4__GetArrayViewFromImage
itkPyBufferIUC4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUC4__GetImageViewFromArray

class itkPyBufferIUI2(object):
    r"""Proxy of C++ itkPyBufferIUI2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUI2
        __init__(self, arg0) -> itkPyBufferIUI2

        Parameters
        ----------
        arg0: itkPyBufferIUI2 const &

        """
        _itkPyBufferPython.itkPyBufferIUI2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUI2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUI2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUI2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUI2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUI2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUI2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUI2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUI2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUI2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUI2_swigregister(itkPyBufferIUI2)
itkPyBufferIUI2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUI2__GetArrayViewFromImage
itkPyBufferIUI2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUI2__GetImageViewFromArray

class itkPyBufferIUI3(object):
    r"""Proxy of C++ itkPyBufferIUI3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUI3
        __init__(self, arg0) -> itkPyBufferIUI3

        Parameters
        ----------
        arg0: itkPyBufferIUI3 const &

        """
        _itkPyBufferPython.itkPyBufferIUI3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUI3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUI3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUI3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUI3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUI3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUI3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUI3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUI3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUI3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUI3_swigregister(itkPyBufferIUI3)
itkPyBufferIUI3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUI3__GetArrayViewFromImage
itkPyBufferIUI3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUI3__GetImageViewFromArray

class itkPyBufferIUI4(object):
    r"""Proxy of C++ itkPyBufferIUI4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUI4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUI4
        __init__(self, arg0) -> itkPyBufferIUI4

        Parameters
        ----------
        arg0: itkPyBufferIUI4 const &

        """
        _itkPyBufferPython.itkPyBufferIUI4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUI4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUI4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUI4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUI4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUI4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUI4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUI4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUI4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUI4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUI4_swigregister(itkPyBufferIUI4)
itkPyBufferIUI4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUI4__GetArrayViewFromImage
itkPyBufferIUI4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUI4__GetImageViewFromArray

class itkPyBufferIUL2(object):
    r"""Proxy of C++ itkPyBufferIUL2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUL2
        __init__(self, arg0) -> itkPyBufferIUL2

        Parameters
        ----------
        arg0: itkPyBufferIUL2 const &

        """
        _itkPyBufferPython.itkPyBufferIUL2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUL2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUL2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUL2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUL2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUL2_swigregister(itkPyBufferIUL2)
itkPyBufferIUL2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage
itkPyBufferIUL2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray

class itkPyBufferIUL3(object):
    r"""Proxy of C++ itkPyBufferIUL3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUL3
        __init__(self, arg0) -> itkPyBufferIUL3

        Parameters
        ----------
        arg0: itkPyBufferIUL3 const &

        """
        _itkPyBufferPython.itkPyBufferIUL3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUL3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUL3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUL3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUL3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUL3_swigregister(itkPyBufferIUL3)
itkPyBufferIUL3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage
itkPyBufferIUL3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray

class itkPyBufferIUL4(object):
    r"""Proxy of C++ itkPyBufferIUL4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUL4
        __init__(self, arg0) -> itkPyBufferIUL4

        Parameters
        ----------
        arg0: itkPyBufferIUL4 const &

        """
        _itkPyBufferPython.itkPyBufferIUL4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUL4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUL4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUL4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUL4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUL4_swigregister(itkPyBufferIUL4)
itkPyBufferIUL4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUL4__GetArrayViewFromImage
itkPyBufferIUL4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUL4__GetImageViewFromArray

class itkPyBufferIULL2(object):
    r"""Proxy of C++ itkPyBufferIULL2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIULL2
        __init__(self, arg0) -> itkPyBufferIULL2

        Parameters
        ----------
        arg0: itkPyBufferIULL2 const &

        """
        _itkPyBufferPython.itkPyBufferIULL2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIULL2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIULL2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "ULL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIULL2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIULL2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIULL2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIULL2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIULL2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIULL2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIULL2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIULL2_swigregister(itkPyBufferIULL2)
itkPyBufferIULL2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIULL2__GetArrayViewFromImage
itkPyBufferIULL2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIULL2__GetImageViewFromArray

class itkPyBufferIULL3(object):
    r"""Proxy of C++ itkPyBufferIULL3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIULL3
        __init__(self, arg0) -> itkPyBufferIULL3

        Parameters
        ----------
        arg0: itkPyBufferIULL3 const &

        """
        _itkPyBufferPython.itkPyBufferIULL3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIULL3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIULL3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "ULL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIULL3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIULL3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIULL3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIULL3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIULL3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIULL3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIULL3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIULL3_swigregister(itkPyBufferIULL3)
itkPyBufferIULL3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIULL3__GetArrayViewFromImage
itkPyBufferIULL3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIULL3__GetImageViewFromArray

class itkPyBufferIULL4(object):
    r"""Proxy of C++ itkPyBufferIULL4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIULL4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIULL4
        __init__(self, arg0) -> itkPyBufferIULL4

        Parameters
        ----------
        arg0: itkPyBufferIULL4 const &

        """
        _itkPyBufferPython.itkPyBufferIULL4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIULL4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIULL4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "ULL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIULL4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIULL4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIULL4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIULL4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIULL4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIULL4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIULL4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIULL4_swigregister(itkPyBufferIULL4)
itkPyBufferIULL4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIULL4__GetArrayViewFromImage
itkPyBufferIULL4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIULL4__GetImageViewFromArray

class itkPyBufferIUS2(object):
    r"""Proxy of C++ itkPyBufferIUS2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUS2
        __init__(self, arg0) -> itkPyBufferIUS2

        Parameters
        ----------
        arg0: itkPyBufferIUS2 const &

        """
        _itkPyBufferPython.itkPyBufferIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUS2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUS2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUS2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUS2_swigregister(itkPyBufferIUS2)
itkPyBufferIUS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage
itkPyBufferIUS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray

class itkPyBufferIUS3(object):
    r"""Proxy of C++ itkPyBufferIUS3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUS3
        __init__(self, arg0) -> itkPyBufferIUS3

        Parameters
        ----------
        arg0: itkPyBufferIUS3 const &

        """
        _itkPyBufferPython.itkPyBufferIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUS3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUS3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUS3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUS3_swigregister(itkPyBufferIUS3)
itkPyBufferIUS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage
itkPyBufferIUS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray

class itkPyBufferIUS4(object):
    r"""Proxy of C++ itkPyBufferIUS4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUS4
        __init__(self, arg0) -> itkPyBufferIUS4

        Parameters
        ----------
        arg0: itkPyBufferIUS4 const &

        """
        _itkPyBufferPython.itkPyBufferIUS4_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUS4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUS4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUS4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUS4_swigregister(itkPyBufferIUS4)
itkPyBufferIUS4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUS4__GetArrayViewFromImage
itkPyBufferIUS4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUS4__GetImageViewFromArray

class itkPyBufferIVD22(object):
    r"""Proxy of C++ itkPyBufferIVD22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD22
        __init__(self, arg0) -> itkPyBufferIVD22

        Parameters
        ----------
        arg0: itkPyBufferIVD22 const &

        """
        _itkPyBufferPython.itkPyBufferIVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD22_swigregister(itkPyBufferIVD22)
itkPyBufferIVD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage
itkPyBufferIVD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray

class itkPyBufferIVD23(object):
    r"""Proxy of C++ itkPyBufferIVD23 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD23
        __init__(self, arg0) -> itkPyBufferIVD23

        Parameters
        ----------
        arg0: itkPyBufferIVD23 const &

        """
        _itkPyBufferPython.itkPyBufferIVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD23._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD23._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD23._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD23.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD23_swigregister(itkPyBufferIVD23)
itkPyBufferIVD23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage
itkPyBufferIVD23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray

class itkPyBufferIVD24(object):
    r"""Proxy of C++ itkPyBufferIVD24 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD24__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD24__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD24
        __init__(self, arg0) -> itkPyBufferIVD24

        Parameters
        ----------
        arg0: itkPyBufferIVD24 const &

        """
        _itkPyBufferPython.itkPyBufferIVD24_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD24(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD24


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD24._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD24.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD24._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD24._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD24._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD24.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD24 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD24_swigregister(itkPyBufferIVD24)
itkPyBufferIVD24__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD24__GetArrayViewFromImage
itkPyBufferIVD24__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD24__GetImageViewFromArray

class itkPyBufferIVD32(object):
    r"""Proxy of C++ itkPyBufferIVD32 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD32
        __init__(self, arg0) -> itkPyBufferIVD32

        Parameters
        ----------
        arg0: itkPyBufferIVD32 const &

        """
        _itkPyBufferPython.itkPyBufferIVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD32._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD32._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD32._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD32.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD32_swigregister(itkPyBufferIVD32)
itkPyBufferIVD32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage
itkPyBufferIVD32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray

class itkPyBufferIVD33(object):
    r"""Proxy of C++ itkPyBufferIVD33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD33
        __init__(self, arg0) -> itkPyBufferIVD33

        Parameters
        ----------
        arg0: itkPyBufferIVD33 const &

        """
        _itkPyBufferPython.itkPyBufferIVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD33_swigregister(itkPyBufferIVD33)
itkPyBufferIVD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage
itkPyBufferIVD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray

class itkPyBufferIVD34(object):
    r"""Proxy of C++ itkPyBufferIVD34 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD34__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD34__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD34
        __init__(self, arg0) -> itkPyBufferIVD34

        Parameters
        ----------
        arg0: itkPyBufferIVD34 const &

        """
        _itkPyBufferPython.itkPyBufferIVD34_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD34(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD34


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD34._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD34.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD34._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD34._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD34._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD34.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD34 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD34_swigregister(itkPyBufferIVD34)
itkPyBufferIVD34__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD34__GetArrayViewFromImage
itkPyBufferIVD34__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD34__GetImageViewFromArray

class itkPyBufferIVD42(object):
    r"""Proxy of C++ itkPyBufferIVD42 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD42
        __init__(self, arg0) -> itkPyBufferIVD42

        Parameters
        ----------
        arg0: itkPyBufferIVD42 const &

        """
        _itkPyBufferPython.itkPyBufferIVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD42._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD42._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD42._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD42.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD42_swigregister(itkPyBufferIVD42)
itkPyBufferIVD42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage
itkPyBufferIVD42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray

class itkPyBufferIVD43(object):
    r"""Proxy of C++ itkPyBufferIVD43 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD43
        __init__(self, arg0) -> itkPyBufferIVD43

        Parameters
        ----------
        arg0: itkPyBufferIVD43 const &

        """
        _itkPyBufferPython.itkPyBufferIVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD43._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD43._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD43._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD43.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD43_swigregister(itkPyBufferIVD43)
itkPyBufferIVD43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage
itkPyBufferIVD43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray

class itkPyBufferIVD44(object):
    r"""Proxy of C++ itkPyBufferIVD44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVD44
        __init__(self, arg0) -> itkPyBufferIVD44

        Parameters
        ----------
        arg0: itkPyBufferIVD44 const &

        """
        _itkPyBufferPython.itkPyBufferIVD44_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVD44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVD44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVD44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD44_swigregister(itkPyBufferIVD44)
itkPyBufferIVD44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD44__GetArrayViewFromImage
itkPyBufferIVD44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD44__GetImageViewFromArray

class itkPyBufferIVF22(object):
    r"""Proxy of C++ itkPyBufferIVF22 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF22
        __init__(self, arg0) -> itkPyBufferIVF22

        Parameters
        ----------
        arg0: itkPyBufferIVF22 const &

        """
        _itkPyBufferPython.itkPyBufferIVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF22._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF22._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF22._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF22.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF22_swigregister(itkPyBufferIVF22)
itkPyBufferIVF22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage
itkPyBufferIVF22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray

class itkPyBufferIVF23(object):
    r"""Proxy of C++ itkPyBufferIVF23 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF23
        __init__(self, arg0) -> itkPyBufferIVF23

        Parameters
        ----------
        arg0: itkPyBufferIVF23 const &

        """
        _itkPyBufferPython.itkPyBufferIVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF23._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF23._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF23._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF23.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF23_swigregister(itkPyBufferIVF23)
itkPyBufferIVF23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage
itkPyBufferIVF23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray

class itkPyBufferIVF24(object):
    r"""Proxy of C++ itkPyBufferIVF24 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF24__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF24__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF24
        __init__(self, arg0) -> itkPyBufferIVF24

        Parameters
        ----------
        arg0: itkPyBufferIVF24 const &

        """
        _itkPyBufferPython.itkPyBufferIVF24_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF24(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF24


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF24._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF24.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF24._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF24._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF24._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF24.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF24 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF24_swigregister(itkPyBufferIVF24)
itkPyBufferIVF24__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF24__GetArrayViewFromImage
itkPyBufferIVF24__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF24__GetImageViewFromArray

class itkPyBufferIVF32(object):
    r"""Proxy of C++ itkPyBufferIVF32 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF32
        __init__(self, arg0) -> itkPyBufferIVF32

        Parameters
        ----------
        arg0: itkPyBufferIVF32 const &

        """
        _itkPyBufferPython.itkPyBufferIVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF32._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF32._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF32._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF32.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF32_swigregister(itkPyBufferIVF32)
itkPyBufferIVF32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage
itkPyBufferIVF32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray

class itkPyBufferIVF33(object):
    r"""Proxy of C++ itkPyBufferIVF33 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF33
        __init__(self, arg0) -> itkPyBufferIVF33

        Parameters
        ----------
        arg0: itkPyBufferIVF33 const &

        """
        _itkPyBufferPython.itkPyBufferIVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF33._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF33._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF33._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF33.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF33_swigregister(itkPyBufferIVF33)
itkPyBufferIVF33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage
itkPyBufferIVF33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray

class itkPyBufferIVF34(object):
    r"""Proxy of C++ itkPyBufferIVF34 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF34__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF34__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF34
        __init__(self, arg0) -> itkPyBufferIVF34

        Parameters
        ----------
        arg0: itkPyBufferIVF34 const &

        """
        _itkPyBufferPython.itkPyBufferIVF34_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF34(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF34


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF34._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF34.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF34._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF34._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF34._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF34.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF34 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF34_swigregister(itkPyBufferIVF34)
itkPyBufferIVF34__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF34__GetArrayViewFromImage
itkPyBufferIVF34__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF34__GetImageViewFromArray

class itkPyBufferIVF42(object):
    r"""Proxy of C++ itkPyBufferIVF42 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF42
        __init__(self, arg0) -> itkPyBufferIVF42

        Parameters
        ----------
        arg0: itkPyBufferIVF42 const &

        """
        _itkPyBufferPython.itkPyBufferIVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF42._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF42._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF42._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF42.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF42_swigregister(itkPyBufferIVF42)
itkPyBufferIVF42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage
itkPyBufferIVF42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray

class itkPyBufferIVF43(object):
    r"""Proxy of C++ itkPyBufferIVF43 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF43
        __init__(self, arg0) -> itkPyBufferIVF43

        Parameters
        ----------
        arg0: itkPyBufferIVF43 const &

        """
        _itkPyBufferPython.itkPyBufferIVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF43._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF43._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF43._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF43.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF43_swigregister(itkPyBufferIVF43)
itkPyBufferIVF43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage
itkPyBufferIVF43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray

class itkPyBufferIVF44(object):
    r"""Proxy of C++ itkPyBufferIVF44 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF44__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF44__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF44
        __init__(self, arg0) -> itkPyBufferIVF44

        Parameters
        ----------
        arg0: itkPyBufferIVF44 const &

        """
        _itkPyBufferPython.itkPyBufferIVF44_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF44(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF44


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF44._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF44.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF44._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF44._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF44._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF44.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF44 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF44_swigregister(itkPyBufferIVF44)
itkPyBufferIVF44__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF44__GetArrayViewFromImage
itkPyBufferIVF44__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF44__GetImageViewFromArray

class itkPyBufferVID2(object):
    r"""Proxy of C++ itkPyBufferVID2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVID2
        __init__(self, arg0) -> itkPyBufferVID2

        Parameters
        ----------
        arg0: itkPyBufferVID2 const &

        """
        _itkPyBufferPython.itkPyBufferVID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVID2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVID2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVID2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVID2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVID2_swigregister(itkPyBufferVID2)
itkPyBufferVID2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage
itkPyBufferVID2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray

class itkPyBufferVID3(object):
    r"""Proxy of C++ itkPyBufferVID3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVID3
        __init__(self, arg0) -> itkPyBufferVID3

        Parameters
        ----------
        arg0: itkPyBufferVID3 const &

        """
        _itkPyBufferPython.itkPyBufferVID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVID3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVID3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVID3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVID3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVID3_swigregister(itkPyBufferVID3)
itkPyBufferVID3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage
itkPyBufferVID3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray

class itkPyBufferVID4(object):
    r"""Proxy of C++ itkPyBufferVID4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVID4
        __init__(self, arg0) -> itkPyBufferVID4

        Parameters
        ----------
        arg0: itkPyBufferVID4 const &

        """
        _itkPyBufferPython.itkPyBufferVID4_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVID4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVID4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVID4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVID4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVID4_swigregister(itkPyBufferVID4)
itkPyBufferVID4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVID4__GetArrayViewFromImage
itkPyBufferVID4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVID4__GetImageViewFromArray

class itkPyBufferVIF2(object):
    r"""Proxy of C++ itkPyBufferVIF2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIF2
        __init__(self, arg0) -> itkPyBufferVIF2

        Parameters
        ----------
        arg0: itkPyBufferVIF2 const &

        """
        _itkPyBufferPython.itkPyBufferVIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIF2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIF2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIF2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIF2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIF2_swigregister(itkPyBufferVIF2)
itkPyBufferVIF2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage
itkPyBufferVIF2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray

class itkPyBufferVIF3(object):
    r"""Proxy of C++ itkPyBufferVIF3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIF3
        __init__(self, arg0) -> itkPyBufferVIF3

        Parameters
        ----------
        arg0: itkPyBufferVIF3 const &

        """
        _itkPyBufferPython.itkPyBufferVIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIF3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIF3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIF3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIF3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIF3_swigregister(itkPyBufferVIF3)
itkPyBufferVIF3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage
itkPyBufferVIF3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray

class itkPyBufferVIF4(object):
    r"""Proxy of C++ itkPyBufferVIF4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIF4
        __init__(self, arg0) -> itkPyBufferVIF4

        Parameters
        ----------
        arg0: itkPyBufferVIF4 const &

        """
        _itkPyBufferPython.itkPyBufferVIF4_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIF4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIF4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIF4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIF4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIF4_swigregister(itkPyBufferVIF4)
itkPyBufferVIF4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIF4__GetArrayViewFromImage
itkPyBufferVIF4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIF4__GetImageViewFromArray

class itkPyBufferVISS2(object):
    r"""Proxy of C++ itkPyBufferVISS2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVISS2
        __init__(self, arg0) -> itkPyBufferVISS2

        Parameters
        ----------
        arg0: itkPyBufferVISS2 const &

        """
        _itkPyBufferPython.itkPyBufferVISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVISS2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVISS2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVISS2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVISS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVISS2_swigregister(itkPyBufferVISS2)
itkPyBufferVISS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage
itkPyBufferVISS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray

class itkPyBufferVISS3(object):
    r"""Proxy of C++ itkPyBufferVISS3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVISS3
        __init__(self, arg0) -> itkPyBufferVISS3

        Parameters
        ----------
        arg0: itkPyBufferVISS3 const &

        """
        _itkPyBufferPython.itkPyBufferVISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVISS3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVISS3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVISS3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVISS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVISS3_swigregister(itkPyBufferVISS3)
itkPyBufferVISS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage
itkPyBufferVISS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray

class itkPyBufferVISS4(object):
    r"""Proxy of C++ itkPyBufferVISS4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVISS4
        __init__(self, arg0) -> itkPyBufferVISS4

        Parameters
        ----------
        arg0: itkPyBufferVISS4 const &

        """
        _itkPyBufferPython.itkPyBufferVISS4_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVISS4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVISS4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVISS4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVISS4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVISS4_swigregister(itkPyBufferVISS4)
itkPyBufferVISS4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVISS4__GetArrayViewFromImage
itkPyBufferVISS4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVISS4__GetImageViewFromArray

class itkPyBufferVIUC2(object):
    r"""Proxy of C++ itkPyBufferVIUC2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUC2
        __init__(self, arg0) -> itkPyBufferVIUC2

        Parameters
        ----------
        arg0: itkPyBufferVIUC2 const &

        """
        _itkPyBufferPython.itkPyBufferVIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUC2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUC2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUC2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUC2_swigregister(itkPyBufferVIUC2)
itkPyBufferVIUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage
itkPyBufferVIUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray

class itkPyBufferVIUC3(object):
    r"""Proxy of C++ itkPyBufferVIUC3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUC3
        __init__(self, arg0) -> itkPyBufferVIUC3

        Parameters
        ----------
        arg0: itkPyBufferVIUC3 const &

        """
        _itkPyBufferPython.itkPyBufferVIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUC3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUC3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUC3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUC3_swigregister(itkPyBufferVIUC3)
itkPyBufferVIUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage
itkPyBufferVIUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray

class itkPyBufferVIUC4(object):
    r"""Proxy of C++ itkPyBufferVIUC4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUC4
        __init__(self, arg0) -> itkPyBufferVIUC4

        Parameters
        ----------
        arg0: itkPyBufferVIUC4 const &

        """
        _itkPyBufferPython.itkPyBufferVIUC4_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUC4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUC4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUC4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUC4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUC4_swigregister(itkPyBufferVIUC4)
itkPyBufferVIUC4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUC4__GetArrayViewFromImage
itkPyBufferVIUC4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUC4__GetImageViewFromArray

class itkPyBufferVIUS2(object):
    r"""Proxy of C++ itkPyBufferVIUS2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUS2
        __init__(self, arg0) -> itkPyBufferVIUS2

        Parameters
        ----------
        arg0: itkPyBufferVIUS2 const &

        """
        _itkPyBufferPython.itkPyBufferVIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUS2._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUS2._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUS2._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS2.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUS2_swigregister(itkPyBufferVIUS2)
itkPyBufferVIUS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage
itkPyBufferVIUS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray

class itkPyBufferVIUS3(object):
    r"""Proxy of C++ itkPyBufferVIUS3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUS3
        __init__(self, arg0) -> itkPyBufferVIUS3

        Parameters
        ----------
        arg0: itkPyBufferVIUS3 const &

        """
        _itkPyBufferPython.itkPyBufferVIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUS3._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUS3._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUS3._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS3.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUS3_swigregister(itkPyBufferVIUS3)
itkPyBufferVIUS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage
itkPyBufferVIUS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray

class itkPyBufferVIUS4(object):
    r"""Proxy of C++ itkPyBufferVIUS4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS4__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS4__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferVIUS4
        __init__(self, arg0) -> itkPyBufferVIUS4

        Parameters
        ----------
        arg0: itkPyBufferVIUS4 const &

        """
        _itkPyBufferPython.itkPyBufferVIUS4_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS4(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS4


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS4._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS4.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferVIUS4._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferVIUS4._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferVIUS4._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS4.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUS4 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUS4_swigregister(itkPyBufferVIUS4)
itkPyBufferVIUS4__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUS4__GetArrayViewFromImage
itkPyBufferVIUS4__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUS4__GetImageViewFromArray

class itkPyVnlD(object):
    r"""Proxy of C++ itkPyVnlD class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlD
        __init__(self, arg0) -> itkPyVnlD

        Parameters
        ----------
        arg0: itkPyVnlD const &

        """
        _itkPyBufferPython.itkPyVnlD_swiginit(self, _itkPyBufferPython.new_itkPyVnlD(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlD


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlD._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlD._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlD in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlD_swigregister(itkPyVnlD)
itkPyVnlD__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector
itkPyVnlD__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray
itkPyVnlD__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix
itkPyVnlD__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray

class itkPyVnlF(object):
    r"""Proxy of C++ itkPyVnlF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlF
        __init__(self, arg0) -> itkPyVnlF

        Parameters
        ----------
        arg0: itkPyVnlF const &

        """
        _itkPyBufferPython.itkPyVnlF_swiginit(self, _itkPyBufferPython.new_itkPyVnlF(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlF


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlF._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlF._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlF in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlF_swigregister(itkPyVnlF)
itkPyVnlF__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector
itkPyVnlF__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray
itkPyVnlF__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix
itkPyVnlF__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray

class itkPyVnlSC(object):
    r"""Proxy of C++ itkPyVnlSC class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlSC
        __init__(self, arg0) -> itkPyVnlSC

        Parameters
        ----------
        arg0: itkPyVnlSC const &

        """
        _itkPyBufferPython.itkPyVnlSC_swiginit(self, _itkPyBufferPython.new_itkPyVnlSC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSC in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSC_swigregister(itkPyVnlSC)
itkPyVnlSC__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector
itkPyVnlSC__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray
itkPyVnlSC__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix
itkPyVnlSC__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray

class itkPyVnlSI(object):
    r"""Proxy of C++ itkPyVnlSI class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlSI
        __init__(self, arg0) -> itkPyVnlSI

        Parameters
        ----------
        arg0: itkPyVnlSI const &

        """
        _itkPyBufferPython.itkPyVnlSI_swiginit(self, _itkPyBufferPython.new_itkPyVnlSI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSI in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSI_swigregister(itkPyVnlSI)
itkPyVnlSI__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector
itkPyVnlSI__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray
itkPyVnlSI__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix
itkPyVnlSI__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray

class itkPyVnlSL(object):
    r"""Proxy of C++ itkPyVnlSL class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlSL
        __init__(self, arg0) -> itkPyVnlSL

        Parameters
        ----------
        arg0: itkPyVnlSL const &

        """
        _itkPyBufferPython.itkPyVnlSL_swiginit(self, _itkPyBufferPython.new_itkPyVnlSL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSL_swigregister(itkPyVnlSL)
itkPyVnlSL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector
itkPyVnlSL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray
itkPyVnlSL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix
itkPyVnlSL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray

class itkPyVnlSLL(object):
    r"""Proxy of C++ itkPyVnlSLL class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSLL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSLL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSLL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSLL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlSLL
        __init__(self, arg0) -> itkPyVnlSLL

        Parameters
        ----------
        arg0: itkPyVnlSLL const &

        """
        _itkPyBufferPython.itkPyVnlSLL_swiginit(self, _itkPyBufferPython.new_itkPyVnlSLL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSLL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SLL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSLL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSLL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSLL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SLL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSLL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSLL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSLL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSLL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSLL_swigregister(itkPyVnlSLL)
itkPyVnlSLL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSLL__GetArrayViewFromVnlVector
itkPyVnlSLL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSLL__GetVnlVectorFromArray
itkPyVnlSLL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSLL__GetArrayViewFromVnlMatrix
itkPyVnlSLL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSLL__GetVnlMatrixFromArray

class itkPyVnlSS(object):
    r"""Proxy of C++ itkPyVnlSS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlSS
        __init__(self, arg0) -> itkPyVnlSS

        Parameters
        ----------
        arg0: itkPyVnlSS const &

        """
        _itkPyBufferPython.itkPyVnlSS_swiginit(self, _itkPyBufferPython.new_itkPyVnlSS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSS in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSS_swigregister(itkPyVnlSS)
itkPyVnlSS__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector
itkPyVnlSS__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray
itkPyVnlSS__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix
itkPyVnlSS__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray

class itkPyVnlUC(object):
    r"""Proxy of C++ itkPyVnlUC class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlUC
        __init__(self, arg0) -> itkPyVnlUC

        Parameters
        ----------
        arg0: itkPyVnlUC const &

        """
        _itkPyBufferPython.itkPyVnlUC_swiginit(self, _itkPyBufferPython.new_itkPyVnlUC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUC in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUC_swigregister(itkPyVnlUC)
itkPyVnlUC__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector
itkPyVnlUC__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray
itkPyVnlUC__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix
itkPyVnlUC__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray

class itkPyVnlUI(object):
    r"""Proxy of C++ itkPyVnlUI class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlUI
        __init__(self, arg0) -> itkPyVnlUI

        Parameters
        ----------
        arg0: itkPyVnlUI const &

        """
        _itkPyBufferPython.itkPyVnlUI_swiginit(self, _itkPyBufferPython.new_itkPyVnlUI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUI in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUI_swigregister(itkPyVnlUI)
itkPyVnlUI__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector
itkPyVnlUI__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray
itkPyVnlUI__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix
itkPyVnlUI__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray

class itkPyVnlUL(object):
    r"""Proxy of C++ itkPyVnlUL class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlUL
        __init__(self, arg0) -> itkPyVnlUL

        Parameters
        ----------
        arg0: itkPyVnlUL const &

        """
        _itkPyBufferPython.itkPyVnlUL_swiginit(self, _itkPyBufferPython.new_itkPyVnlUL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUL_swigregister(itkPyVnlUL)
itkPyVnlUL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector
itkPyVnlUL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray
itkPyVnlUL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix
itkPyVnlUL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray

class itkPyVnlULL(object):
    r"""Proxy of C++ itkPyVnlULL class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlULL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlULL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlULL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlULL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlULL
        __init__(self, arg0) -> itkPyVnlULL

        Parameters
        ----------
        arg0: itkPyVnlULL const &

        """
        _itkPyBufferPython.itkPyVnlULL_swiginit(self, _itkPyBufferPython.new_itkPyVnlULL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlULL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "ULL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlULL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlULL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlULL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "ULL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlULL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlULL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlULL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlULL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlULL_swigregister(itkPyVnlULL)
itkPyVnlULL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlULL__GetArrayViewFromVnlVector
itkPyVnlULL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlULL__GetVnlVectorFromArray
itkPyVnlULL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlULL__GetArrayViewFromVnlMatrix
itkPyVnlULL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlULL__GetVnlMatrixFromArray

class itkPyVnlUS(object):
    r"""Proxy of C++ itkPyVnlUS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyVnlUS
        __init__(self, arg0) -> itkPyVnlUS

        Parameters
        ----------
        arg0: itkPyVnlUS const &

        """
        _itkPyBufferPython.itkPyVnlUS_swiginit(self, _itkPyBufferPython.new_itkPyVnlUS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUS in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUS_swigregister(itkPyVnlUS)
itkPyVnlUS__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector
itkPyVnlUS__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray
itkPyVnlUS__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix
itkPyVnlUS__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray



