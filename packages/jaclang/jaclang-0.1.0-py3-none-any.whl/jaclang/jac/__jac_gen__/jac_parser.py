# The file was automatically generated by Lark v1.1.7
__version__ = "1.1.7"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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S7+BvHTnlyr0x/il0lbX9OJDJr7qQ/hOHMK/fgj/74fwrx/Cq/gQvpZDpa9lRvEfKu9VfaHN1vaG+clGlxGYWXyAdVzxXIVZOtj4k5OsD/wYdqHGJcVLWKxYpfhQ0aLYqvhI4VY4FR8rFikeVyxRuBS1ijpFvaJBsVTxpMKj8CqWKZYrVihWKp5SPK1YrWhULFA0KZoVCxVrFGsV6xTrFRsUGxWbFJsVPsUzCr/iWcUWxXOKVkWbIqBoVzyv2KbYrtiheEHxoqJDsUuxW7FHsVdRo9in2K94SfGy4hXFAcVBxauK1xSHFIcVRxRHFccUxxV3FRHFCcVJRaeiS9Gt6FH0Kk4p+hRBRb/CUFQrBhQhxWOKqwq74pxilqJCEVZMV9xUzFHcUcxQzFVMVlQqYgqHYppipuKi4pJivmKqYpLCppinmKK4opgtMAI/jmKT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KT12KTLxabWZXf7fvnfMrb5lgXUv05Tv192vvnzMa2fRRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKsdhRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKsdhRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKsdhRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKsdhRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKsdhRntaM4qx3FWe0ozmpHcVY7irPaUZzVjuKs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4VBMU8xUXFRcUsxXTFVMUtgU8xRTFFcUswVGoYZrsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsclqsckWi40H+9OjmGeMYho2iunGKKYbo5hujGIOOYrJ4yimi6OYsI1iujiKedsoZo2jmJ+MYhY3ilncKGZxo5i0jGLSMopJyyimdqOYQ45ihjeKGd4oJjSjmEOOYr43iqnkKCako5hRjmISOIqpzyimPqOY5I5iyjuKCeIoJoijmN2OYp44inniKOaJo5gnjmKSO4oJ1ChmjaOYNY5i5juKWdUopryjmFyNYkY5ihllSSegq1AnNAg1Qteg65AdugE1QBVQM9QH3YRuQbehO1AddBeKQ29BkyEH1ApNg2qhdqgemg/thKZC96AOqAaarTICXryz0heKB3cfh56AFkNLIBdUC7mhOqgeaoCWQk9CXmgZtBxaAa2EnoKaoLVQC7QR2gRthnzQM5AfehZ6DmqDtkIB6HloG/QitAfaCzmh/ZAHehpaBa2GGqEFUDO0EFoHrYc2QPugLVAr1A5th3ZAO6EXoA5oF7QbqoHWQC9BL0OvQAegg9Cr0GvQIegwdAQ6Ch2DjkMnoJNQJ9QF9UKnoD6oH6qGBqAQ1A31QEHIUBmBZZ/1t2VYOws5bI98yq/N+Ey/LWM5Wsov43X2ZSTcl5G9JV2F7FAD1ASdg2ZBFVAzFIamQzehFmgOdAfaCNVBm6AZ0FxoMlQJxSAHNA2qhdqhmdBFqB66BM2HFkFToUmQDeqA5kFToL3QFWg2tFRlBFagKagtPuRx6AloMbQEckG1kBuqg+qhBmgp9CTkgbzQMmg5tAJaCT0FPQ2tglZDjdACqAlqhhZCa6C10DqoBVoPbYA2QpugzZAPegbyQ89CW6DnoFaoDdoKBaB26HloG7Qd2gHthF6AXoQ6oF3QbmgPtBeqgZzQPmg/9BL0MvQKdAA6CL2qeuvPwrbif+XuoPSgQ9Bh6Ah0FDoGHYdOQCehTqgL6oZ6oF7oFNQHBaF+yICqoQEopDICK7+1xWBr+7PCB79R+DNu6vstPqVnztr+u3wXSnhHcVLRqehSdCt6FGcV7yp6FacUlxTvKUKKPkVQcVnRr3hfYSjuKqoVA4oLig8UNYrHFMsUrytOK84olihmKc4pmhRhxXlFRDFd0aKYo9io2KSIKmYo5ireUFQqYoqZiouKRYpJCptinsJUvKmYotiruKJYqvAorioGFY2Ka4rrCrvihqJBUaFoVtxU3FLcVtxR1CniiskKh6JVMU1Rq2hX1CvmK3YqpiruKToUswVG4OkftVPpnx9G/yyH0b+nQ+h/N8+e/1nhxl9WmN+vq7BXFa/bWVj4zrddN+N/115J1jUgV/Stkv5uv6QCG61X0MjnV3p8tldb4RtkPV8rvu3r7vvzcltdPsfcYP0jGwo3Pir23o04/vOnVqV7QrFYsUrxoaJFsVXxkcKtcCo+VixSPK5YonApahV1inpFg2Kp4kmFR+FVLFMsV6xQrFQ8pXhasVrRqFigaFI0KxYq1ijWKtYp1is2KDYqNik2K3yKZxR+xbOKLYrnFK2KNkVA0a54XrFNsV2xQ/GC4kVFh2KXYrdij2KvokaxT7Ff8ZLiZcUrigOKg4pXFa8pDikOK44ojiqOKY4r7ioiihOKk4pORZeiW9Gj6FWcUvQpgop+haGoVgwoQorHFFcVdsU5xSxFhSKsmK64qZijuKOYoZirmKyoVMQUDsU0xUzFRcUlxXzFVMUkhU0xTzFFcUUxW2AEmjDo+Wf6fCriHcVJRaeiS9Gt6FGcVbyr6FWcUlxSvKcIKfoUQcVlRb/ifYWhuKuoVgwoLgiMQDN+q9224iEFp8oIrJl4U7uvFS/tXFv8jImxW6GYF5pusziPC3yxeN3JOmylpXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VxumsNE5npXE6K43TWWmczkrjdFYap7PSOJ2VLgVfSzHIFheemh/IP7G3+NAnoFXQh1ALtBX6CHJCH0MLVUZgffFLm3guDmGTZwibPEPY5BnCRs4QNnKGsJEzhK2bIWzWDGGzpqQLUAh6C/oA6oZ6oEtQELoMGVCNyigs73Vx+p/lx1fCYsUqxYeKFsVWxUcKt8Kp+FixSPG4YonCpahV1CnqFQ2KpYonFR6FV7FMsVyxQrFS8ZTiacVqRaNigaJJ0axYqFijWKtYp1iv2KDYqNik2KzwKZ5R+BXPKrYonlO0KtoUAUW74nnFNsV2xQ7FC4oXFR2KXYrdij2KvYoaxT7FfsVLipcVrygOKA4qXlW8pjikOKw4ojiqOKY4rririChOKE4qOhVdim5Fj6JXcUrRpwgq+hWGoloxoAgpHlNcVdgV5xSzFBWKsGK64qZijuKOYoZirmKyolIRUzgU0xQzFRcVlxTzFVMVkxQ2xTzFFMUVxWyBEdiIYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpPTYpMrFptNxWJjba3Oxy6ztc+7BNvfE5vLAZu1afhN667ytu5fFW4stG5M7NU+eibh8cKNh5PMT95vxl24Y9nEm+BcmlQsHrZAc3EzcHNxU36StSn/U4V/sdK6ETWLG+5tSwt3bLa+hEPWF+Ozbv2JdatiYpaxtLRm800MHf+0OHR8Bu8n9xOYxJT0DnQS6oS6oG6oBzoLvQv1QqegS9B7UAjqg4LQZagfeh8yoLtQNTQAXYAeg16HZkHnoDB0HopAG6FNUBSaC70BzYQuQougSZANmge9CU2BlkIeqBG6Bl2HKqBm6CZ0C7oD1UEOqBWaBtVD86Gd0FToHtQB1UDLoNPQGWgJ1ARNh1qgOdAMqBKKQSa0F7oCXYUGITt0A2qAbkNxaDL0AVQLtUOzVUbAj18t/1OYHv5U6SHPYmNnOQaTy/HdXV76hC3F1C7n8NtWDlshLix/SumDlfigEXgO/+Qv4qsqaQO0DdoKbVEZgVZcE3O8+JDHoSegxdASyAXVQm6oDqqHGqCl0JOQB/JCy6Dl0ApoJfQU9DS0CloNNUILoCaoGVoIrYHWQuugFmg9tAHaCG2CNkM+6BnIDz0LbYGeg1qhNmgrFIDaoeehbdB2aAe0E3oBehHqgHZBu6E90F6oBnJC+6D90EvQy9Ar0AHoIPQq9Bp0CDoMHYGOQseg49AJ6CTUCXVB3VAP1AudgvqgINQPGVA1NACFVEag7dFz40aF+alvEjpx7DXw9612/M/NH/SxV+tsa5+uTD45CPu3fpJ8a+H/eJn5w3r89YuFh+wxP9vJ8om3ep04BFs+/DpxGrZ8CLZ89rV8GvZ7OwT76NnX8rHYH+Ah2MAz1rP4vClnz7/z+7Q+UfjI6+b360zsVrQmEVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EfSyEVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRXK4bweW6EVyuG8HluhFcrhvB5boRbN1HcLluBJfrRnC5bgSX60ZwuW4El+tGcLluBJfrRnC5bkmvQYegw9AR6Ch0DDoOnYBOQp1QF9QN9UC90CmoDwpC/ZABVUMDUAh6DLoK2f//9u47OsoqDQN4EkgISTQUC00FrkgVUSyAiIKKCiaiCCIahkkyJEPKhCl0uNRAYOBSRuy9XRRp1s/ee++999572fnmPuy+z56zf+w5nl33bP7xxzMOaTPfe9973xlCqZjSXErZlOZRKqBkKLWlVEipA6VcSi0oLabUmVJrSkWUllBaSqkTpXxKOZSyKHWklEepiVIbmRIlJc1vLfzXDeG/1Qj6v4m2svEv9hbD5ndBjf4P/8LXUnpZ87rMtmwmpTmUiik1UJpLaRqleZTmU9KUhlMaQWkBpS6UOlBaRKmI0hJKSyl1o5RDKYtSR0rLKOVR6kepP6VaSoMoJSmtopRNaQilKCVDaQ2ldZR6U+pMaRSl1pT6UOpEaSylfEobKI2n1JXSAEqzKM2m1INSDaU6SoMpFVAaRqktpTilQkrTKc2gtJBSC0qLKUUo1VOKUWqktJzSREoJSk2UplJaQWklpfaUVlPqS2ktpfWUUpTOoJRLqSelUkptZEqUnMBv4PDfuLEp88aNMc0tw5/YMoxtbG4Z/s9bhhOpZdBUoDU1EJrKtaZyralcayrXmsq1pjZEUxuiqQ3R1IZoakM0FX1NTYmmpkRTU6JpedC0PGhaHjS1L5oWC03NjKZmRtNCoqm10dTaaFpkNC0ymhYZTU2QpiVH05KjacnRtORoap40NU+amidNzZOm5klT86SpedK0qGla1DQ1VpoaK00LnqYFT9OCp2nB09SQaWrINC2GmhZDTc2apqVRU+umqXXT1LppWkQ1LaKaFlFNTZ6mJk9Tk6epydPU5GlaijW1fJpaPk3LtKZlWtMyrWmZ1tQqamoVNbWKmhZ0TQu6pjZSUxupqY3U1EZqaiM1tZGa2khNLYN2LcNJO36757Et/Fdjjc3UtVHpZ+q4xn8cwA6kI7uB7hji5Mxdn0//1T7+8KmVvxrd61fPCek/vO3/ox95/k3j/Zt2FEpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTRUKA0VSkOF0lChNFQoDRVKQ4XSUKE0VCgNFUpDhdJQoTSuUI6jYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCiYaCizkLRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFDRMFC57m+8exW/u22jXyJjJafI27a62yY0nzz9SSdPzSdOf4ETJ//4L9z43zx5OjVzQfmve2tMb7G6+y+W+h4/wYC/6RrpP0bX5bjPUjInxz32JQX+Hu0Y//91z/E/zMTMhxnp/5j8D79H+sOU+LefRv8C04+iermwRYYaGWplqJOhXoaIDHNk2CpDgwzTZFgqwzYZZsgQlSEmw3IZ4jJslyEhw3oZusgwXYaFMlwrQ1cZdpdhgAwzZZglw2wZeshQLMNcGQbLME+G+TJoGQpkGCZDWxmGyzBChgUyFMrQQYZFMrSQYbEMRTIskaGbDDkyZMnQUYZGGZbJkCfDRBmaZOgnQ38ZVsiwUoZBMiRlWCVDexlWy9BXhmwZhshgZFgjw1oZ1snQW4aUDLkydJZhlAytZegpQ6kMfWToJMNYGfJl2CDDeBnaiJAoOT1TsnY8UTz5VPXkM8CTzzRPfvGe/B49+Rk8+SP35LXryevQk88ATz6anrxCPfloevJy9eQV6snr0JMPrScvSk8+gJ682jx5tXmyMHnyofXk1ebJB9CTV5snH0BPlmBPPpqevCg9+Wh68gr15BXqyUvPk1ebJ682L/M4l+144+gb2X5nOSnzsO/YSAyljcRQ2lINdS1rgHbwlnbwlnbwlnbwlnbwlnbwlnbwlnbwll46Zmk/b2k/b+llZZb285b2+pZ295b285b285b285b285b285b285Z24pb215Z21JZ2zZZ2zZZ2zZZ2zZZ2zZZ2zZZ2zZb2yZZ2xpZ2xpZ2xpb2wpb2wpb2tJZ2qpZ2qpaeUpZ2o5bOVSydgVg6A7F0BmLpDMTSGYilUw9Lpx6WTjYsnWVYOsuwtIe2dO5g6bKwdH5g6YzA0hmBpTMCS2cElk4FLJ0KWDoVsLTzd+lQSmWUJlEKUJpMKUipnFIFpUpKIUpTKFVRqqYUpjSVUg2lWkp1lOopRSg1UJpGaQalKKUYpTilBKUulKbLlCiZ3Lxrb961/2/s2v0debvGv/brRf5eOrdkZgmJZFEsHozGA+n/xkOx1LzU1IdysrJG7xRLFoTqK//p5pLNObFE9fZk8ZhgNBaurxoZjdTH03dLJapvKEv1yjRIl8QyXOq4zHG54wrHlQ7r2Oi4ynG1Y5PjGsdmxxbHVsc2x3bHtY7rHNc7bnDc6Lgphg4uw82OWxy3Om5z3O64w3Gn4y7H3Y57HPc67nPc73jA8aDjIcfDjkccjzoeczzueMLxpOMpx9OOZxzPOp5zPO94wfGi4yXHy45XHK86XnO87njD8abjLcfbjncc7zrec7zv+MDxoeMjx8eOTxyfOj5zfO74wvGl4yvH145vHN86vnN87/jB8aPjJ8fPjl8cvzp+c/zu+CNDSVa2MxvmwBawJcyFebAVzIetYQEshEVwJ7gzLIZtYFvYDraHu8Bd4W5wd9gBdoSdYGfYBe4B94R7wa6wG+wOFdwb9oD7wJ6wF+wN+8C+sB/cF/aH+8EBcH94ABwID4QHwYPhIXAQHAyHwEPhUHgYHAYPh0fA4XAEPBIeBY+GI+Ex8Fh4HBwFR8PjYQkshSfAMfBEeBIcC0+G4+B4eAqcAE+FE+Fp8HRYBifBAJwMg7AcVsBKGIJTYBWshmE4FdbAWlgH62EENsBpMApjMA4TcDqcAWfCWXA2nAPnwnlwPtRwAVwIF8HFcAlcChvhMrgcNsEVcCVMwlVwNTRwDVwL18H1MAXPgBvgmfAseDY8B54Lz4PnwwvghfAieDG8BF4KL4OXwyvgldDCjfAqeDXcBK+Bm+EWuBVug9vhtfA6eD28Ad4Ib4IevBneAm+Ft8Hb4R3wTngXvBveA++F98H74QPwQfgQfBg+Ah+Fj8HH4RPwSfgUfBo+A5+Fz8Hn4QvwRfgSfBm+Al+Fr8HX4RvwTfgWfBu+A9+F78H34QfwQ/gR/Bh+Aj+Fn8HP4RfwS/gV/Bp+A7+F38Hv4Q/wR/gT/Bn+An+Fv8Hf4R8wK8eZDXNgC9gS5sI82Armw9awABbCIrgT3BkWwzawLWwH28Nd4K5wN7g77AA7wk6wM+wC94B7wr1gV9gNdocK7g17wH1gT9gL9oZ9YF/YD+4L+8P94AC4PzwADoQHwoPgwfAQOAgOhkPgoXAoPAwOg4fDI+BwOAIeCY+CR8OR8Bh4LDwOjoKj4fGwBJbCE+AYeCI8CY6FJ8NxcDw8BU6Ap8KJ8DR4OiyDk2AAToZBWA4rYCUMwSmwClbDMJwKa2AtrIP1MAIb4DQYhTEYhwk4Hc6AM+EsOBvOgXPhPDgfargALoSL4GK4BC6FjXAZXA6b4Aq4EibhKrgaGrgGroXr4HqYgmfADfBMeBY8G54Dz4XnwfPhBfBCeBG8GF4CL4WXwcvhFfBKaOFGeBW8Gm6C18DNcAvcCrfB7TmxULJVpCEejtT7Rwu9krmVofJEVaopmReLR8MV8fSfimtCoYZAsLY2EI/UhNL3a0oWxKOhUKCiNhiLpUqTuRXBiupQ+uZWDZFYvDY0M1VanT310ZysrGRuOoWiqeptycJ4NFgfmxKJ1qVzaeYMo8wdZQST+Q3RcCQajs9KJfPq0/cI1qaSrYN15eGqRObGlsFEPJJK5kZDVekP3pRs3xCNNASrgvFQIP0Zw+6rT3+hmU8WqEh/qeXBihr/G0q2qwvOKk/frTZYEaqO1FaGov49dw5VhuOBeChaF64P1qa/h+rNo7OqtzQliyLR9F1ClYFYKB5LLU8WhesaItF4oCEYr46lylLJwlgkEa0IZW5If+v56Y+cqApnfnj+cUzL44PRmlSi/98A7cJFjQ=='
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'eJzNXQl8G0fVj+8zzuEkTZuebpM4SRM3Lb1cJ6lsy4m6GsmV7Dhp7CxreW3LkSUjyUncOG0phV6G0ta9oVCglB7QQjk/6MENBUrLDf1KgXKVq0C5+YBvV7vSzM7sjFZ6K5fyI8nOat783/+9efNmdnb2iqpbFi0qW6T/d3S+VdL/mKuMK5Pq/FxVjz/o6Zufq5lS0mk1GZ/X71UdVGLT2s2W1sGRTa2DWwZHNm7YMav/vWlD6z7VO7Rv0+ahHfrVDk3CaEwZS80Pzc9VJJVD83OnteWv1TY/Vy0fio6kx7V6rVLZdVX/0f5bpM7VynJ6ZkqV5fm5ul4DUcg7Pz1XO5WMJpLR9My8tGi8aa6hT01ORuNKrFsdnZ+WyjTQ4+Vz9d3BLjncF/IFds6PV+pl1XMntbS0tG6ZrZ9dvGHjDu3fs+vXr89da/+eH68dmh+vn1vbZvxwMD47mLT8NFuiXbXNjzfqeKuzeMebxpdMjy/VMY0vm5bKDRw1vXsDfl/AmwOxsr19aqa9PdeucZlt+ti23O1sW0ZBtrlGTnMVRnPVlMrNLfv2tyyuH9qoabBv/3r9X+txW/rNweRgPHvb+HdOtXJOW5VGW5WdwaA/11J9X3Jane1RYik120BjGy7LyqyUqmhxVSZ0aUAO+AI5gY2Dw/FEejC1KRofHM6KbGojS7k2KDMkV2PJvrBFcjSlidAFWSTj0nySawzJFbu8e3Jil5+x7/CeoX1nbD5f2Tzq2dwjD23KCl/Rxt7LNlHBYbnWbKKT4KThjH3DnZqYrYTsxW1EYT6hdabQYFcfpuOMfYmgju1cQmpTG1maT2y9KdYXIMTq2mZUloc2YrFkaVZsGUdsg+logX4/drTKQCKec7HqNv0KO1clLaLRDAfSgDfcJQc8CPfE1R3b9ymbL/VsvkQeMv9hBXtcG+8X+fhYnAVOtrdK3NrqNnFbPJKaTA379vbSAa8ilU5mxVe1aBct81rArDeDaVi7SchZYgYsXQ5px4poPI2FaBe6kPEUUXOpUbNOr2kMIdm62niQUHK1a1oyl0z9ZUb9Wr2+3xfG1Stj0VSudnWLfsVUXk403tff68d8V6Wnp2IqbjxzydRvJtQOewm1UyqhtnbB1FxBwO72ER2qciQaIWDrV0zllURlSxytHE4kYriyfsVUXkXo3Lm3zxvGOg/PpNUU1jlzydQ/htDZE9iLdVbiM1hn7YKpuZqArf0fk12pD9UYtn7FVD7WhK2F456Q13sJUXs0mbgU19avmNrHGbUbtNqeTs3RPQTjtcqw5t0KZr2+JVvCyFmDUQQ7L/ISUqoTwxMqllHbYlwzEo436dMkeAP9CGuhxqcnsRb6FVP3BFw3EOwmGIgnRgj+9Cum7okYuW9nIBjCtaujY/FEUsXIjWtGwkmm+TQJu31hH9FRD0ZTUaKjZi6Z6ifngqkc8loF1CRVi4i6FrOAEXIKxhDu9Qzgwa0qNaUcimMMmUumegsmcMDXtwsTeCiqZZA5AvUrpu6puGlvoC+EHb9KjaeTM7jpzCVT/TTC7nsI3SvVw1Giv+tXTN21hO1QbzBEeF10ciqRJLzOuGYkrMPk+wJd/n7CeWqi8UhsGvtPXYtZwAhZj1XoCQWRpQNOWjog67qtRt0qvQPiiFOu5MJNZYvCxpoNBGndOwmHV0fGCIfXr5i6GzFpAx6/5A1h0g4psQNqEpNmXDMSNmGLe8J7A13Y4kpqJh7BFs9cMtVPJ6oPeMj+ohxSyP6SuWSqb8a6a0GacBgtKBMOo18xdbdg3T3hsJd0GCWVUkmHMa4ZCW3YXr4ebK/oKLZXdJSpdQZhLz9Rr1KN4ZqavWI2dbeSdcOkrYlZgV43xdr6TJyr9wSxoStGE0QKo10wFc/CavYFsZrpBFYznWBqvQbX6sRxoHx4BtcaZiPA2dgfBnb5yFzj0HiUzDUyl0z1c/AQ1hUM9PkC/VhCbSQRT0fj0yoewrIljJxzMYzOkNcjEcN/UlUOEMO/fslUP8+o3qhV7/aFvYGdHqJf1o1EU2p8TMGds6ElV8SIOh8j2evz+rsxkpmoGhvBSDKXTPV27DBhydeLHSZ1IDqFHUa/YupegDtIyGuNqEnVGlGNa0ZCBymhrz8UICWkp5NxUoJ+zUjYhiV0e/3ePkxjxYgaw36rXTB1t2OHJ4eiCmIgqmqxG4Z24Ea9e7q8vYTi6uGIOkUoblwzEi7EQ0mPL+Dx+3HzNaP6UkpsBg8lZgEjxINNH/L4iN5elVSiKaIvZC6Z6p1EdAoQ0SlORCeW8C6iFjEGRYkxKMqOQd3YzXpDvt1Y2alk9KCSJsZNs4CR4MXG6u3vxIRPTQ/HohFMuHHNVO8hAQSxweqmkom0lmKqI7iz5YoYKTsxiF3ECFwxjofgqpZxmzF4F/aYnf5gpwfPNqrHYolhJYYVMK4ZCT7cdJcHm6siosRx09oFU/Ei3HS4z9PnwyNwdSqtpEnujGtGgmRy5wmFggMyhl7RsXlzru027SI3KZcq6Dmy3yKDGF02b96OZWgXAhnI9HdDRqcPB6sOQkq1jmS7YEEiYPY9Ux25dyspaHAfKWhwnwBP0CIoJPeeidUaItUaEqrVS+PBYsqHcgRXalJyy4JSOS3kYhrLVoJirJNGMVbJRkzIpLiLtnVVx+CmwdzaVE1b5lKgVNgqCBu8Sq+4HQvKXAoE9ZkjdpeNuTKg9llBiQzWb5VlsVjlEAGrum1IjGo3g4q0PSaqShck4HuAQUQ4I6lcdRupm42kPWY3N8KLHMRDeWP7WPtsuxFWcsvcTW1kKda0lpa71+y4u7whLym1vmN8+2zHuJpUc6w1tuEyLLGalniJKTHs9fdYJaa02ik1NkpKzJUJJO4zJfoCvj6rxKhWOxqPpkmJuTKBxEHTfcP9vd4QKbKmIzU9pSZz8urazIKssBqphhY2ZMILBYMUvKQGJZlIWODlygTw9pvGNuZkVmMf0sxqzMVIYxOlAmPLJlJ9YcSCtD2u1deXRNoxUlwmQPpaU6I+87RKVLXa+pyTlJgrE0hUTN2NpSOr7gmtvrFkROpOlAp0H84iDfQjUmp1u76MlJNX22Zc555PsAgj2Vjc6fP7+vaSwha3KxoYZTgai6ZncjKXtFmKMcg6WvRIVrTc6+v1yj0DON8vb9+Ox4r27YJQoZpBxxTSKZFSOtqxlI52gZRRs4swQCoGZ4mxT7sQCBkzjckCqegYnCWSi8FZgZRx03TdWv+yItlCItkiQhI11dFl0EC2kEC2CIRMmMwakxl5F7mKX76ZsM9mEZQDJhSvf7cvTHpPxeCOdkKfHSLzxLJdud+vjQZ4glo+uAPDGNyRe7YhldESJrOMeLuClhhTdmFWQkXbhQIBcZyyegKY0Op162aV+AjuUMY11gWPtuazvgSecxALEzWDs4Ozs3hxoq7NLLBjxZQ0ZULydHfL3osJYjdtI4jdtE1A7OtMEeH+TlJE+eZthHlFApKmANTvt2LYSGLYKBKRMkQ09viDmmm6fbtJQVWDbYNt23BWlLkU5DJpEw8lpoIQUkWKsMEznVUpaKG1fC3ByVqRgINmHOjMuIpFxjpCxjqRjEOmv3bqXmLVZJbUZFYk5DAGsoeWsp+Usl8kZQZLCWjxhFTnMkKdy0QyLjVl+MO7fD0WGRUdHQQS7UJg3COmlBArZft2Qop2IZAya9rXwEIMFh3EYNEhUOaoKSBECdhOxMTtoph4mSGgwk+s8JR3EFx2iLi83Ky9k6y9nai9XVT7CqN2ObGHpPwUovIposqvN5sOEIsOVafMxhN47botc4kDKRP/rsTpXqg/bHGndgJHuwjHG8wY2hX0B/HyQVk7DuXtglB+VdYBOkOeLkxD2RFc/Yig+huz5qeqH8XVjwqqv8moXhn2IjzpL7sAV75AUPlq03pewnrbCNa2iVi7JlsZU162Dbe7TdDutabhuwnDl+NUQht8twhqX2c27MeVyzpwwx2CqtebVXcSVbfjqtsFVedyToKQB9c+Hdc+XVD7zaaZev39xMogngxrKm8SVH+L2TjyBYj6ZZtx45sFtW8wo3+4z6PNooMDxDR642Bui4c2jdauBAZ/KylGG6EJPTYSemwUILnR7K25wZmAoo2jBBTtfwIoN2UdiJBQjutXErVtUNxs1taGZMzlWszlWkHdebO7dloTt7J1uPo6QfVbTEN2WtK1cpzPa9BnBfVvxc3vsQjYTwjYLxBwGxZAht2yyzD+ywTVb88Gu15PyEusjA+2Eu23CgTckQ13tIANhIANAgF3GgJq/OGL+z3ELoNyvCCkSdgnkHCXKSHESBgiJAwJJLzNkFDfE+4L6SvHxOOdcv3BY+6J4GALXjE2B6y3m70oU9dLulCuYmULWc9s826yzV6flxgr6vbtHzwyeLQFb5BrbDOKBlvw9jh6i9ZF+pUh+x3ZbqnL7vSGiSfRR47MHj2Kh+PMpWAS8U6TWz1KeokZXvOpgxtzu0oHN546e+qWXMw4ps24md1Tat7Ot7XsHjOWD+CA2Ni6o33fyXWNi+uHNmS5CHC0/3dO+3dpleeqE8noWDRudu9jJ5RITImPbTmoxkcSyS0xJXlgS0w9rCbn56r6EgfU+PzN+tbkUL/fq5Wk0koyPS8t0n0lPR/S97E1BBLx7N7f+em5OvXwlBJPRRPx+aFsCJlMjEzrj2WbJrorFy2aVuaqEskRrQVp0VyVEosqqfnAXE1iKq1VSmV2Oy85oKpTshKLyWkdQmr+2rmajNyRrfPXji8NzC1Jq5NTMSWtyqnEdDKiagIWayXpGTkaH4lG1NT8Bh1aSGs2aMqd1goq9YL5aendWiMTF1Rm9l6Pl0/s0P7VOnGh9mcOq7RES4FNFQ3UE17tT41g0+4jiYicVsZyt81iNaZOqvpOPUvxElk25Mo6gfIZudvqhE/7S1o0cZH2V2BCMiBNIO3vaycC+p+athPBzM1e7U9Nq4mL9Yra3yH9b+k9VlUGtH/ZIp64hLhjlAwSJSaQsuKB3OsUyCADZD8LpLx4IO/NC4TFoRitVhTf6n15WzWaqCy+ifc5ZJjnnEtN55T1XVmy9pv5vGaoKh7t/U79YYbxhyMskOrigTzg0B9IHKY/1BTf6oPcEMOaQZqTqt0INvBo8hAXda4x6WGp1hasAWrx1IwcSYyo8nAsETkwTxEKgPZ+K7TbOWacazQ33WmhdjJNtw+Ibx9w2H6DsXHQtnlAVHvYYfM15gMEumlAaHvEYdN1SjIyHjV2IFsbBwS9DzpsvFYbYDOOR7cNCGEfcti2uZHQ2i4gYj3qsN1648mtfFBJ0q0DIteHuTGAbA9dVCYtEwUtYn/5XP1oNJZWk3JiOq3lb01ztThhNDVRIlrSlrIJckuUVCo6Fs8ETOM9BMttYzlo4usZxZomnql0JQx+xErBV1gDmGPX09qFtXGj/FuV9Jj2HeaX8JTrow5hkluO7NB+g0FbAH5ATPuYU5pfhNMMiH8f53cIwm3RDWXSclGHMFddbfTAO9LcduRPWKG/wmX4L/YM57baue26/wMFlttF6LZTfpJrbSPMoyfLpGZhtpbdZ24H23gXze5OvU3WBHeAT1m1aazi8bykyr6LNVe5OUl8jEsuHr/RC2XSinwEZ146saMRv1Viezc1PSxnXrO2DiOlIf9xq7Yncclv4ZB/Gqe81VWjPMFP+rMTD7SkXFopyPqzLzxbwcKT/iet0M5mGTTtR7xnbosBQM+nufRQcx10Rrm0SkBS7iV0t1n6DBehZTKCdpVLq/OlbOZrUYV0ntxrTHaVsgimFP29MEs98wmTXa1Gs1Y0rU6mFiTl+6yVQ8Trq8WSJOLBeJWrsOFCwALA1z/36rEgUAgwmn+e2zWs6wSovEI6XtQ3yBf+Sq8xwJG/kDcYZKCgsyukE0QKZ55Z22nKvVGrpiJ2FKyQZaJleSo2nZK3ujjMftGq8Zu5w+xbOcPpTZzyeVeH2S9BYZJwjJJbWYCAvvJlNwHCp11POYXjiBfAEtRX8gJhccAXn74qiFzk4IjGK6QTRR15Za77ZSoYj6DO5IQp/Scuds2vWZX4JI+6J1nqAD3t6bwhMKMmuq1COkmYD+nBbEROqqOwERvO49etGn2Fx+PTrvL4DJdHYqkXPVYhnSIcOUfUSCKppBNJJpMzTmpwzdueteJ9nsfST1xl6Rt5W81LxOIcnfII4WzwkP5Nh4y8zDICiNzfgjPSRDISidGUAKL5tx1S8n+uRvPvcLsSrSlaXymtFUYlvYJsecxyNM8iOn8asSQaH1eTWjgckXWxtBkaJ9XJYTXp+srId6101FTzxvb6anpsb2RKmqrt05Gl9C9LNGn63kIos7zazVTv+wsB+XimHJ4U/qB44I7dxI5rQMB5biEgc7kGxKz/dR+4DbOA56TPuw+QyyPggeoPubGfGvfRTKW0ThT6l+sP9+V0IhOr5ci4op/TsCAB+wVxKmgMR+j+SqlVsABKnCDk9hLoj6z49rGugCGY5425vU78Y4cQcmcw2QIABPWfFAAgc+qZLQBAcH6R6yRkoof+VSltFnhJsyzjXxurRWe5uI/op1yQTC6EjquStgiQrtZm1tYqBtzXuAj3Z3y42RVHeSSR1s8uQR1VUluRT6AbDBnW5Tt42Pg5Fz1eL0VylXRGkbBLM9v+BRe1hSaUrpK2ioDbknpUvIhao8RnLCsOcHV+aVXnbk5cmLi3mpnxAMLhS1wScyqit1dJZwn6V0NqSo1ElZiFD3iX+pUV2SPcsYJd/oHT8mv+QIqbQ1+sks4REJPdiOUuL7+xQnuCxwu7zg+n5bf8QJFrDf2pSjpfxApxurDb+cXvrPie5nFjF5Dg7LzMD0hkF0HHVUsdogfQ2bNR3Gbn91Z8z3Mzj+zpJ24T9AeHAPBZLm4nX390SkH2xBu3k69XnALIHuJjCwAwz/0T10mNdV50bbXUKfDOWv1XlvVPuGP+2Yrp39xQb7ZNrDTCnfIv/FCPm0MPVEvefLudMucb224ac3/Jrz6Dze3541+tXCyu4U3Vl9ZwVg5q6Cn8Cs4vV9G/LNGy398WTqXVNcyyCSBU/X3hgLcw5fAlwH9A4Tt2HDveAQHynwsHnMs7YDnw/0oF34ZlwKLgv0oFk8spYGnw34K0NzsaoleqpR7xqmBmBS4hZ6rYrQqWJqb/hwuebA+tqZF2iuBnzxOxG6uaZRmLMnYunE3pZoyllretTLkhO7lgtdGiMqveCtfDRjieNM701wmebxU/PqEyME4uquIHH1RexvUawpJod43kEzkNP73Rj2mxTZXUw1NJLVfS30x3rQ+gCkqdoyzJfMDgFBNVOm1e/FomwJ5VfHvmXkVEd9dIqLgtIg2mDLt9EQCzVVOob+XwNnFXjYtrYqgmf7N5GcEfUbDdOI35YndNAMxc6xT5xPs4weQBdpQvPglEdS4wKeSq+DwP1Tt1ro+zzlV8foYa+D3RqilaUitdnO89APOYcN47Yfrx44VNSJmFbbOt0el4xGoBU1IpXslBjRRJn+X68Rc4fvwlTvlTzKD+Vabk6YWZmqLFr6aWc43qQf1t3UhMmU5Rzz0mnnFzJouaXlVr/owpec796S5aUjIdHfinnb0AkXHpq6oL1zqAoLtsATVi/c3GOsXPnNHyV1UXrnWKn16jZscauRrV7exSW7wWK14lLbgWqStel5ULooujnlJfvBarXiUtuBZpKF6XY8C6FNkjGovHvHpBMHPZXlw88mNLgNyRtzcVj/m4BcHMZXtJ8cjX8KdEloUFlKyVQo6WWDMbMO2WWBd4HnM8pdn+Wp5NlFqKaWF+rtYyngOYh5zA539p9suwcm6V6OO1Uvi/flpq+fBtgS9mA+x9IsVkimvvg7X2ffAwp/xS2j8mZgvymCs4cq9kyuH+dFLJWGB0nriMKSlYU8DM9uQF1HQOrilgfnuKY00BHuyGNQHz3pYF0dEFOwJmwqeCdSyJ1QDz4dNKoJELNgLMh9cKlogtIR4dXyf1FX0GU33mjRZ9ZyK95J77aLftxiTj866Zd0ksIzV8+FxHKf4015TPcszxTcZw3y7BALfefZziE7EmvssmfIBhq7UEPP+8BIPOBjBO1vpcPgEDx8YS4ISH+k1gVKxNuewBAvjpJcAJD8KbBTsg8KwDjdRJ/eJtM8aHJewi6dKcHHlKSSrMEVrZj1IscBTeQmneVMezx7I6zmmEdXR0WMn8Eh6F28A4WVRG+TF1bkbbM0qAEx5bt+ZHxZIB3n6OzszfLDjwnSVYz2C6HHp3nbRb1IOPlWW6krHF7Rx6MSJz03LMM7wzvobSpZ1nph2smQB962xB9MNqom/USQMi7vAnnpy+FmjWY8KaUb6wu8bOoUi4iNtxEafjBjnlF7MBBmCsc53iJL6VVSxaoyTM+WW/q4HzPMf8D8P5B4TS8x3jLAnDgGjc7ipyeMp6gWDmazkyATXXS3uK3a68UpZJYUY0P3eB9iV3UCq+nkv5VRzKrylBLrVN8AjG5MrY8butXrqkiI+gcDa2wuncTgGf542Pd7g6Pu7I32yer/wwD1bci5sXOuXkvSwngDDogXLCfBQFHuA6nVLxKEsFII51Qamw+UgLfKLd7ZSMJ1kyADNpL5SM2nElZX11BL5bp8cpF19juQBsrNnJj7NYS/Tzeum1gEesxDddCnvKukSHYHzJZcG+4oJ2UZR8jzsgPscZEJ/nlP+YyapeLMHQ6YPizzwS32V/UOnEC4wOBWgFGEMuAlvlj3CrAAYjyTF+nveAmAcMWX4w8gJwAsY45BgnzxNADAPGwQAYeQE4AQNnkD9YMJEabW2QFNGYkSe2C77ysFRPQ0ZkvT61tQQe/HspFU+p5wzDrfVupu8XC1YIGW1RrEEaFq5ycU7U/+9YxQpRup7FUmx6+zn1tFefR5TAR8qwIPnJUYXuaZAiRZ4zZvdEG05gn6Ab0k9h0KcapBHhYWMhb19/KCDv8gXsH6+XRod+vg5kg+inDZIqfAWUu2fA/IS8nUoNqWh8LKbKdtMZgE676c2VvNihuho7BgRLJaSiaFmjNCYMG317e+VuH2eDYu6D8o4ZzRvIBbVyH5+3hRLo9/vloOR66r+HonKKG5pS9fYD8TSn/BATymY4vzzC/PIo80t46NvrVNO5Gt0rwl53nQJgXsAc4hLH5r2BY5wbOeU3M0a7hWc0wBxin2Oj1elG6+vv9XMYXnizASYgg47Ndi/HPPdxyu9nzPYgz2yAicmQY7NlIrDfx/kI5KtgNcCkZr9jq32SY53HOOVPMFb7NM9qgMmO7NhqgvNaxewClgtfmx+dceNZNtcALBcqjkmp1DUvwuMAr9cNO+Xkh4y7KOD34SKOmWkcno7G0tG4bVcVcgN49W3EKTe/Zv0F8N6aKnh+aqEBTS2WEqJTHjMD2t5e149oRaMUxL9xmDESIU+A3g8LT+DHnCLIkNAZDNL9Cn4cz3hBEGzmCPCnddGC7MAmpPCtYBNOEXCzK/iDugMFGcImVVDAA3esIBp6/EEPBwNg8J0syBnYpQsFPMDGC2Khc2+fl35eAh9tE04x1Ge6hOA7xoBRdUqwUkN+xXiqSTpS7AaYplRaSauT+pskNkvBpdr58jpKs20NvAz1wgb7TLSbKYfPzJN8vmma0J1N0qxg0DxGlq01jO9MnOfeSckoJdiXmWt7Hn20SbpMAFR8zBwAXpqCt5c1sZnDH1JiB7Kbiqj2Acaczt9+diFTOaRE03YHUpbkC8fooHNkM1E1NlIgMkAicMgxsgZztbswaIAM4XAh0PAX1B1DAyQOM86hjagxNa0WCA2QUFzqGFpdJJ2MFQgMkGUccc6ZkkqpBZsTkH7MOu+eSSWaKtSagKTkqNOQWncomh63DaiAbOQyp63XHxqPxlTb5gGz/MudNl87mrAfTABz+CscN55Oztg2DpjJv95p4zXRUdu2ASfJXOm8M9g8sc7bGQAnxbyhgPE9s9Uhkw45Rra0eGRXObXXEmN/QSR92D77WlY8hjc6ZqfADbjLi8f0Joe8TPywgVkIay6+2auhVPA34K4oHtU1Tsn4NUvGyuKbvdZxVm5+d90unqwqvv3rnLZv1zXN5o8pvvnrBfs36M6IXl4q3eL6/g3zTklegJjja5cbGlDLMulW4Z4aaUD29TjelMTXx+w8aowelXI36NwJzsCbKQaWNPLWFZY3cr4lQdQwSlYxJauJEviqw1sWBPNxLGbAFPaGEmOGT2XfKlgdwS6JhpZJt+X9lpO/tP0B7vY3UsqeyzVHO8ccHYw5trvq5DcJzZENBOjGZdLt+c0R5rzMUJKgerNop2I22UcPL5PuEC7BasA5B7oInKVBPRxRp2xXZhtHo3ElFptx25XmKXX3cF1pH8eVhhhXkl11pVtKgFBxNTre6ipCeCy8TbBNkfQw9PNl0p2CteIVskz83FjRPt/FJePbBc87zIYzZ3/+Z5l0V753orx7ury9nLSMG7arMl/qKPCAgtKEnTsoLq7i+tDVHB+6lvHyG1zth3cKNhhYghM6f7n0NuFOYv0lNV/A4/c7D5Bwhu8SBPbcEhLav1y6O19g7+FsduYvPOiO1hcswjs7OQwVlInAuXsbxd19PO8U8pP5frLtGyj6HISzr78YTQFe/nZB4oLhoxeWS/cIQxJXVf4e7ZJ8Kh3dTSn0FGs648azTFyBP5R7hyDCE6vGqLxZepdwv7x+mOEuH2eP7UL3hncKfASvxKPNzdK7iz6hsVHXSVZSdj5UGq3uEcR3Cxi0p1l6j0ixVXregCsYh2xsPYNecTR/46IK76JU+AvP1//ZyCyyAbz83YJ1mKyS6PJm6V7hoOhWlgKn8T2UPtWLOTTWLXaTxnsFwYJ48obuaZbemy9YhDw+3qyxJG/avZfCvppH2ZrF7kfZ+wT5Pvk0FX2mWbovXyLtCYe9oYITaf6oVhq+30ep3MrybabLmxjCjfLNi91Mju8XDAn4STv6W7P0PsGESx8RwpKP8+V3AF0P0PuvOO6Z6TudIa+H3hYNd9IHnULQz+/vCgb6fIF+zqZPwFT9IUFXITdroNNWSPfn6yrdXr+3byGjzPsF6MldMKhnhfRAPvQhb2+wgI4OR/8BIXq8vQiNr5AezI9efxazgOgfptCP8yL8gRJE+EcEQyOxZwxdv0J6KN/QuNfn9XcvIHEfpLAf5hF3pATEfUjgc+Q+RPTQCun9gsjcNKLlH/ExZcx+nwuAnkcphNfw4mJjUj0YTdEbF+EUfdgpgHp+84CI/BGnzTdEx+KJpD3/gMXSjwo8hGwR/XGF9IF8Ucm3MxDkvP1X1H4ZgF99TBAyCEOiY1dKD+cLGbt9Yd4XAVLTw5m38WTjzTx6pspVuiSPgz9O6fwINyt8lJMVfmQxvYj6MbqkRF+E/QQYO4N04hNsjgvoqf9TAoSfYX4Jf/zxScFChiWGInml9Ei+heqQl+/9C+zen6IU+w7XAN/nGOC5BXLmx8BIn3fVdR8H4/lZCRz1Cb6j0vkGum2l9EGRqzbq8xFf2BvY6dlpPwCVZph5UjDMEO9ZoE+slD6Ub5jxDHgK6Ghw7J8WYcePctD3V0qP5hv5BYcuVirpxOSreg7UZyhFFzdxt+800RF6RZN9h1jV5Ob6yWeFj4JzlKDKVdJHRKaonIqyx+IUs8NNvPOkJFb6HMXBqayV7JSEzwA+zyffaApJq6SPC3uA/jN5WGF2tNT2+nq9cs+A/YTTqgicwS9QirTzGLTBC6fxi4I1QNweunSV9EnhNlM1puUocmRcZTeTZdjslDh02mgF5/RLlFaIx6ktbjirXxZtZiFaRI+tkh4XJnPD0fQh/SlCIkk7qdev5XhykF53FegF5/UpSq/X8ni1ww2n9SuCgEs0iCqOkT4t9Nbsjw8ztAqOhbPTCU7pVymdUlxXtQMN5/RrAlclW0TeY6TPOSJVidMz6mqN1D28w/bs1ILT+jSl1pvy0krChtP6dQe06i2i64+Rvijc6p4aj44yr7xrhHoC9gHVViE4oc9QCt3BI5QCDKfyWT6VZlvo88dITwl3LcQSY9GIQn91uToU3uXrsc/eKTXgBH6DUuMhXj7LResvFC2A9G/mR8sBC19d/ZZga0K2NbR4tfS0yOQVgSDnmDQaMNy036YAf5lv2khickpJ2mX7nPjIgwuw7XegcPX9crzww8ML8Ifv5sfLgQtfaf+ewBezraHUaumbwixOSUbT45NqOhqhmYxMTsmJKXoeR+sBd9HvU3r8jpu52WCFx/AfiFYtcIPowdXSd4RT5bSapJclqpAv0G+/1chOGTiXz1HKlC3hnnJnA7ey11842sKpv+WCaxZl/svB/t/8sO1Qw+P584KpeqYptOhY6QfCDcyjSiTN5OoVKMiZolsUgBv8h5QCJ3INzgHa7dvtHCigm70ABFrX4w8GQ3JBcAGO8SMgXOHnAe3RAoaCH+dHaw8WfvTcT/g9KNsYet2x0o8EmwGqphKHVAYToFO8SGEK8o2nzVZ42RjNFbwP/NQxLsHAwYEF8PWfOYbFHyA4qAA+/XPB3MpwGPTEsdLPhHOrSCIeVyP0FFX8KVXKG+Eh+heUIlO8zsnAhSc3vxTmiEZr6LfHSr8UdM8G/XlLNCLbrZIDaHmJgvYGrtfZAjDzElMJ20TVSia8+/7KDcSLR6KpgkEDOvevBas9JEq0+zjpNwIvWEr82HalH+AKv6EwvrMYYvUnnuFezwDnA/Fc+HC/+K0b8Os9svDZTl4FAD7yO76PsM2i54+Tfi9wlOrp+JS77vEyBe8xLr98kkz+TZK5j3xo8HDn+L0gPzIbQ5vXSK8IGK1IqqMu0vkHCtEzXDrzJLGW5/Bwpv5YIC7ut9DtcAF6xyt8C2Ysg0bXSH8VHRF6SIklp7NfDHPRkH+igL0kTHN5q2IceHB7/pnPG9Umml8j/UP8KeSUHFFi9LJznSmGGUfFOgEo/wul0z+4uRyNGJ7L/VWQy2VbQ8+tkf4l8EVr34C74N/onTBLuX1WvHPB5Vjyd8e48o27bkeTfzhnTJjQ2OICTLf+KdhtgbsZ2no8Ki8TOFid8dxKZvZjwX3t/yiEW1jmTAx+MQaAX/3LMQZjYYGLAeBB/y4Ew55giIsB4C3/cYqhNrNpgQsBsPC0qLwAGrTBj4sBcHRxmVMM1SjIBwA4oLjcMYBu324uAMBBxBVOATTm1m+5MACHDlc6N0S/nwsAcLZwlWMA4f5OLgDA8cLVjgF4uvmuCDhguMZxfxzw+EP9YS4GwDnDtRQGcrJlPs5E55yAlopGMP0Jsi9MD7rw4auOwnY5j5/M/lrOJzkAQ1e90/Z1AgLM8THwcauhIAI47QPGrEan7ZcHOC9KA0arxU4br9jJvAINH6eaHLfu57UOGKSWOCZ+p/vf41nquHG/+5/iWea4cS+HdsCQtJwfDI3JA/rICWiNKBQ2qCNjqhY0ZXcXoJopYI/zWKlR4jN2bQOi4AqnbTeaS4mRcSXKLNoAouDK/ABynx3q9YS8hR7jVR2yqwWfH65yStwSnTg5kojF1EiaxAcPoscUZDw5Fk2rSXb7HyCOruZ3KWuTaOuJqEXUtew/pQjvW8dSCF/iUWT3lUt49zrOcfMl+RjgGqfNN0xOa+yn0slofIxmH9BJjnfafpXg43OADnKC0/YrgrzvIAJ6x4mOW+/kpXeALOMkx63v8u5xPc042XHrpfjk3yn8uMSEY/TSieh0UWiqH4lG0rK+z9PNPTktFMSWZbzpYUrltA6IS6c6bn1Mjdu3DghLpzltvT5zvp9t84CotNZp87UZyx9kh0xASFrntPEa3e42bQMC0nrHVk9PT8VUu9YBAanVMe0Zq9s0DohHG/gRwTL2oSdPQmeLosFKWSZ+bxxavXWri4FhIx9pzWgW5Y9PQufYo8w+xukJ94Vk/bkw5413XZQ8pSTT9LdEajM1vczTUfjDwk18zUg4qO5kdK7IBCtkGf/cPP3zTBctcDqF8wDrqOAAvJnPBXZ/JJ2MzhOaucYfvrjfwzkSqC5zOKjNAa81IdtacAtvobQ6zDJnHgRwZJn9a/+XM+Xwh59tfK6JQIemTkbnC8kWTkANQbbfvBVMQAFcn0FpdT2X67dwuL6pBFxvFUSv7ICGbjkZtedhmv+FYa5Xl+rjwmcK3AdjQR89GV0gVIoLfMFPNz2L0uhBzkg88SHiBjzpfI0g/hPdB/3oZLRNPLgVc1BsMfQvwce0WGvCbXA2RcZjvO5bnLb5kAPMeE5pkdvYCb7L5NxSYYYvJJ6XH1oek8InJecLspHcHAg9eArqKjpsL5flrCQzZTuLzkoOHNRSuij95lCpwno7pfPvuePnK5zx869EDaPk7yUYUS8A4+SiAnSoDsE4n7UjeuEU1F18IPcHF/L83W2CwYlYhUCVLchbfEreEI3H1SS1olHipHy7IH/Bqzvo9BbUU3T6K9CrVPnvDoFaeMkMXdyCdhYdtIRqlSYsXShYqCDRoIMtaFeRncvtj+hwthcT9ZwfjwZn0EMxeOFyXsDsWk4HcO9y+xC6k/mlj/NLifglPPh3CqISsSyNvtiCfEV7OW/g/S/2ktL2wS6K9f1cD1I4XhBh/EXl/HKM+WWU88sDzC9fx/wS7nHdeR7p5rYAoFNPRZJwt0T25zbb/gHG8VIAr2SNY7TfTMKVp+MpZdTNUw17nOJYZsFhhwKQh+3km8tWf3TFqSgojBR2x4k2jkZjaWYghHe0XRT627gd7U7a+e0348D93weBFI2PqIflVCwaYQ6EAdj4IqeQbG1X2x3s47/gx2wpgk9oJccMPsIwWKOD5bx6MvFhdmgFzHn9AJgV3fZnJNhBBDyvQ/zObRNUUMVpKFRw167R973IQfqDPKXt9wFKsae43H+NGfS+bj88lioeBEsBtTRxotcp1MIdYcGDyMWOaf8FQ/tLHNqFweW3rgaXUAngc4OODXRA0AkLJqBkRoduPA31FxxuhM/QppSkMrmQz9D6KF2rmnlmqm2mzVTfbJ+mNzHl8CDUL5gGEqShx09DA64/gyrhQ5DdlF5rWP7zYIDn8QNOMdhwB8/f94h2qlE6oxPWon1C83Jpymtku29Lw+27l9LuNRxuJy4gbsBNeolwDQ0PvSi8Fg0Vv5jr2ur10dIuAO+j6OjhRjkfJ6ZJTPRDnF9eXILoN1gC/FycgL48BMbJYzXoHD8g59pfMvxctIAUSwaj5aICZE+vFTxJVZKR8UyajG5ai2ThluPE8IR+IJa77xkpFLYjvJGu3vx0obuvGg07bb42M5OzaRzQNyOOG4/rHz+3aRzQsUYETpFrDr24Fo2IB6NAsNvL+4xEaT7VrQqQ56yE/rEWqWLk3u6dC4x8VJAyE+6Nlq1Do+KUecDjl7yhhUU/JkBPxAZ0+jo0JkYf7LzI29XHQ1+rpiKZ7yu6mPSNi3wmPj1pIJfWofE8PhPoRwvLelQ09R2OxqJpY5kDDa9DUfGzV0+nz+/r28v96EtqSo1ElZjdqglAgQlKga9xx8Rn7MdEvkMAAv8BgTOPxRLDJg3o5nVoQuzMO/3BTo9/IZ05xse+MjOeJ5Jy1jXM52KPrkMxoRqcitbZgMXh3NNnktLnV1wP+S2dcxIJjHu+Ec+Px7jxMjtDBKQDCafN/oVtFpAITPG9ablubzmdkDMkm670j3VoEu5KXLsB/Oh1lCbVKzgENqxwc2afFBGoa6kTqBNpErhlPYr/1/bFFKXMKh6Ha1zlMO2Aw8w4bXKorkcJF5wwN/S7R+A0pck6HoGbXCXwoCBNIB9CobvWo6Rommek0Ep8xsVJ3iEK3DkcTubqMo2PJtnzDwHUHHbaek2m9XTCxSnejGBLarY19MP16GCezC0UCg7IIbl3q3uLfs3Ec1QlabtxCrd7put57aUUMxJrFXPQD6ywXyrpXUEvQO1mfglPBo7kx2l6j0mW6wcmzIre9cn1F3RuK5px4kX+V8mL/KXwoqMUN1GuF8U4XhRnvChdAi+6LD9Oixe5f+zG5flWTfSQj+Zb0ex/sxOVJBRdQVFzNdeJruM40RzjRDeVwIlenx+nOYYbZHXSnz6He9GVgmkz8cUE9PtWdLnwaJ3sj+3GeoAp30Dhu5dHUQ4tO9wDLHQVnx7qmxLolA3oSmFP436BULSpCEDdGx2YVs9WPBvQVULgDV2lSFfyPEYmGnU/QLyJouYJboD4DCdAfI4JEE+VIEBcnR+nGSC6SpWsXCPYqm3p8+gdG9DVjvzI3bHGoR+VJFu5liLnea4f/YjjRz9h/OiXJfCj6/LjtPqR++nK9QI/smwARWUb0XVFvyNWzhxw6zgjKdX+rznB7nk7VOjsjWhOSIADZQS7cOja0bTq5scR30ypW7+Ss16ybKWb6yVvcc5yRmE0uxG9Rcgyu9Jv+ontN1pL85rZDfRLQpWcjrtUjamZEHgomh6XRxLMx1oBIN7qFESNCcLFBOzG/G23sneMkg2Eg8E33twEQNLGIgEs8N9MIbm1ircFm7ebtyRPseadwrLcMUo8K+2Hxy6WOIAz3UIfZcolriE6OZVIpq2xURBZ4ezd6hSb5Y5R0ruSLgkxfMLZu41COFPNY6+229sV5G9msPuICoC5253istwxSmSO3ymu+t0d9Ft8LEIzl01ND2e6pRbB02l1xMUgfmd+DK3sHaMk7iobd1FIRmt4flSXeZyTSk86ym7gnvQ2p8gsd4ySS5k+OFuCPvh2CuG2Oi53xpb9gwr9xnWJuLvbKTLLHaPkWoa760vA3TsohG9iEZrBf1KdHNbyRYvjwXvgO/O338reMUpud7UH3kMhCTfwHt+l0kraNqUD8PCu/K23sneMkve4ysO7KSSXNfIWF9XDEXUqLY+4ulX2Pfmbb2XvGCWPuErEvRSSv/OQaCm+/n6KQp/nWaKg8l6nuCx3jJJPMUHl8RIElfsohHu4J+2O2h98DmDnfU7brg73hXyBna4fPH9/fgCt7B2j5CuuTs4eACB5lucWgCnagxSeOPfw6cxBuL0+L3PCCNw/HnIKoi4DotMb7nLdRd6fH4ODw2OKPJ0F4FAfcIrbcscoebEEDvUwAM9LPDyAF2MeAeB5mTPp+gMTsV/hIQe8PPNBCvmfuR7JObKoRGPdh5zistwxShavokuWrHJ9rJve8v9xKhlt'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
