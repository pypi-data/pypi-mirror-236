//LICENSE TODO

{{#if PLC}}
#include <stdint.h>
#include <stdbool.h>
#include <iec_std_lib.h>
#include <limits.h> //for UINT_MAX
#include "common_base.h"
#include "plc.h"
#include "usart.h"
#include "ia8.h"
#include "io16.h"
#include "delay.h"
#include "pilot_comm.h"

//module specific includes
{{#each PLC.modules}}{{#if include}}#include "{{include}}"
{{/if}}{{/each}}

/*
 * Prototypes of functions provided by generated C PLC
 **/
void config_run__(unsigned long tick);
void config_init__(void);

/*
 *  Variables used by generated C softPLC and plugins
 **/
IEC_TIME __CURRENT_TIME;
IEC_BOOL __DEBUG = 0;
unsigned long long __tick = 0ULL;

/*
 *  Variable generated by C PLC and plugins
 **/
extern long long common_ticktime__;
extern long greatest_tick_count__;

/* Effective tick time with 1ms default value */
static long long Ttick = 1;

/* cycle time */
unsigned int cycle_current = 0; // time for the full cycle
unsigned int cycle_current_comm = 0; //time until comm done
unsigned int cycle_current_read = 0; //time until read
unsigned int cycle_current_program = 0; //time for program
unsigned int cycle_current_write = 0; //time until write

unsigned int cycle_min = UINT_MAX;
unsigned int cycle_max = 0;

// plc_state
int plc_state = 1;

/* Help to quit cleanly when init fail at a certain level */
static int init_level = 0;

static int GetPlcVariableLength(int number)
{
	switch(number)
	{ {{#each PLC.variables}}
		  case {{number}}: return sizeof({{type}}); break;{{/each}}
	}
	return 0;
}

int read_from_plc_variable(uint16_t varnumber, uint8_t *buffer, int index)
{
	switch(varnumber & 0xFFF)
	{
		{{#each PLC.variables}}
      case {{number}}:     
    {{#if isGlobal}}
    if (varnumber & PLC_VAR_SUBSCRIBE_BIT)
      {{extern}}.flags |= __IEC_SUBSCRIBE_FLAG;
    if (varnumber & PLC_VAR_UNSUBSCRIBE_BIT)
      {{extern}}.flags &= ~__IEC_SUBSCRIBE_FLAG;
    {{else}}
    if (varnumber & PLC_VAR_SUBSCRIBE_BIT)
      {{plcVarName}}.flags |= __IEC_SUBSCRIBE_FLAG;
    if (varnumber & PLC_VAR_UNSUBSCRIBE_BIT)
      {{plcVarName}}.flags &= ~__IEC_SUBSCRIBE_FLAG;
    {{/if}}

    {{#if isString}}memcpy(&buffer[index], (void*){{{get}}}, ((uint8_t*){{{get}}})[0]+1); index += ((uint8_t*){{{get}}})[0]+1; break;{{else}} memcpy(&buffer[index], (void*){{{get}}}, sizeof({{type}})); index += sizeof({{type}}); break;{{/if}}
    {{/each}}
	}
  return index;
}

static uint16_t *varnumbers;
static int varcount=0;

int configure_plc_read_variables(uint16_t *variables, int count)
{
	int i;
	int bytes = 0;

	varnumbers = variables;
	varcount = count;

	for(i=0; i<varcount; i++) {
    bytes += GetPlcVariableLength(varnumbers[i]);
  }

	return bytes;
}

int read_plc_variables(uint8_t *buffer)
{
	int i;
	int index = 0;
	for(i=0; i<varcount; i++)
		index = read_from_plc_variable(varnumbers[i], buffer, index);
	return index;
}

static uint16_t *varWrite;
static int varBufCount=0;
void configure_plc_write_variables(uint16_t *variables, int count)
{
  int i;
  BOOL force;
  varWrite = variables;
  varBufCount = count;

  /*
  for(i=0;i<count;i++) {
    force = (varWrite[i] & PLC_FORCE_BIT) ? TRUE : FALSE;
    switch(varWrite[i] & ~PLC_FORCE_BIT) {
      {{#each PLC.variables}}{{#if isGlobal}}case {{number}}: __FORCE_VAR({{plcVarName}},force); break; {{/if}}{{/each}}
    }
  */

}

int write_to_plc_variable(uint16_t varnumber, uint8_t *buffer, int index)  
{
switch (varnumber & 0xFFF)
  {
    {{#each PLC.variables}}case {{number}}:
        {{#if isGlobal}}
        if (varnumber & PLC_VAR_UNFORCE_BIT) 
          {{extern}}.flags &= ~__IEC_FORCE_FLAG;
        else
        {
          if (varnumber & PLC_VAR_FORCE_BIT)
          {
            {{extern}}.flags |= __IEC_FORCE_FLAG;
            {{#if isString}}
            memcpy((void*)&{{extern}}.fvalue, &buffer[index], buffer[index]+1);
            index += ((uint8_t*){ {{{get}}})[0]+1; 
            {{else}}
            memcpy((void*)&{{extern}}.fvalue, &buffer[index], sizeof({{type}}));
            index += sizeof({{type}});
            {{/if}}
          }
          else
          {
            {{#if isString}}
            memcpy((void*){{{get}}}, &buffer[index], buffer[index]+1);
            index += ((uint8_t*){{{get}}})[0]+1; 
            {{else}}
            memcpy((void*){{{get}}}, &buffer[index], sizeof({{type}}));
            {{{extern}}}.last_write_tick = __tick;
            index += sizeof({{type}});
            {{/if}}
          }
        }{{else}}//todo - handle flags{{#if isString}}
        memcpy((void*){{{get}}}, &buffer[index], buffer[index]+1);
        index += ((uint8_t*){{{get}}})[0]+1; 
        {{else}}
        memcpy((void*){{{get}}}, &buffer[index], sizeof({{type}}));
        index += sizeof({{type}});{{/if}}{{/if}}
        break;
      {{/each}}
   }
}

void write_plc_variables(uint8_t *buffer, int count)
{
  int i, index=0;
  for(i=0;i<varBufCount;i++)
    index = write_to_plc_variable(varWrite[i], buffer, index);

  //return index == count ? 1 : 0;
}

//uint8_t PlcPortConfig(uint8_t slot, uint8_t port, uint16_t baud, uint8_t parity, uint8_t databits, uint8_t stopbits, uint8_t flowctrl, uint8_t xonchar, uint8_t xoffchar)
void plc_port_config(uint8_t slot, uint8_t port, uint16_t baud)
{
  rpc_pilot_comm_set_baudrate((module_slot_t)slot, (module_slot_t)port, (int)baud);
}

uint8_t plc_port_send(uint8_t slot, uint8_t port, uint8_t *data, uint16_t length)
{
  int i;
  //for (i=0;i<length;i++)
  //  pilot_send_data_to_module(slot, port, data[i]);
}

void plc_init()
{
  /* initialize PLC variables */
  __CURRENT_TIME.tv_nsec = 0;
  __CURRENT_TIME.tv_sec = 0;

  //init located variables
  {{#each PLC.mem}}memset(located_{{region}}, 0, {{size}});
  {{/each}}

  config_init__();


  {{#each PLC.calls.init}}{{{this}}}
  {{/each}}

  {{#each PLC.subscriptions}}{{{this}}}
  {{/each}}
}

void read_plc_inputs()
{
  {{#each PLC.calls.read}}{{{this}}}
  {{/each}}
}

void write_plc_outputs()
{
  {{#each PLC.calls.write}}{{{this}}}
  {{/each}}
}

int find_next_updated_variable()
{
    {{#each PLC.variables}}{{#if isGlobal}}if ({{extern}}.flags & __IEC_SUBSCRIBE_FLAG && {{extern}}.flags & __IEC_DIRTY_FLAG )
      {
        {{extern}}.flags &= ~__IEC_DIRTY_FLAG; //clear dirty flag
        return {{number}};
      }{{/if}}{{/each}}
    return -1;
}

{{/if}}