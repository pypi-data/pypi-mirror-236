# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_filt.ipynb.

# %% auto 0
__all__ = ['StrFlag', 'makefilt', 'just', 'allbut', 'justabc', 'justnum', 'justpunc', 'droppunc', 'dropquote', 'splitget',
           'stripjoin', 'prepart', 'midpart', 'endpart']

# %% ../nbs/09_filt.ipynb 4
import string
from typing import Callable, Optional, TypeAlias, Union
from nchr import DOT, NIL, SPACE, S_
from chck.strs import isquote

# %% ../nbs/09_filt.ipynb 5
StrFlag: TypeAlias = Callable[[str], bool]

# %% ../nbs/09_filt.ipynb 7
def makefilt(sflag: Union[str, StrFlag]) -> StrFlag:
    'Make a filter from a boolean function.'
    if isinstance(sflag, str):
        def chrflag(s: str) -> bool: return s in sflag
    elif isinstance(sflag, Callable):
        def chrflag(s: str) -> bool: return sflag(s)
    else:
        def chrflag(s: str) -> bool: return s == sflag
    return chrflag

# %% ../nbs/09_filt.ipynb 8
def just(s: str, flag: Callable[[str], bool]) -> str:
    '''Filters a string for just the specified characters'''
    return ''.join(list(filter(makefilt(flag), s)))

def allbut(s: str, flag: Callable[[str], bool]) -> str:
    '''Filters a string for all but the specified characters'''
    flag = makefilt(flag)
    call = lambda c: not flag(c)
    return just(s, call)

def justabc(s: str) -> str:
    '''Filters a string for just alpha values'''
    return just(s, str.isalpha)

def justnum(s: str) -> str:
    '''Filters a string for just numeric values'''
    return just(s, str.isnumeric)

def justpunc(s: str) -> str:
    '''Filters a string for just punctuation values'''
    return just(s, string.punctuation)
    
def droppunc(s: str) -> str:
    return s.translate(str.maketrans(NIL, NIL, string.punctuation))

def dropquote(s: str) -> str:
    return just(s, lambda c: not isquote(c))

def splitget(s: str, sep: str = S_, idx: int = 0) -> str:
    parts = s.split(sep)
    return parts[idx]

def stripjoin(*args: str, sep: str = DOT) -> str:
    return sep.join([s.strip(sep) for s in args])

def prepart(s:str, sep: Optional[str] = SPACE) -> str:
    pre, *_ = s.partition(sep)
    return pre

def midpart(s:str, sep: Optional[str] = SPACE) -> str:
    _, mid, _ = s.partition(sep)
    return mid

def endpart(s:str, sep: Optional[str] = SPACE) -> str:
    *_, end = s.partition(sep)
    return end
