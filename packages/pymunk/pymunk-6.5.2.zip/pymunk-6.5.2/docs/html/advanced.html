<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Advanced &#8212; Pymunk  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=cb3efb50" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" data-goatcounter="https://pymunk.goatcounter.com/count" src="//gc.zgo.at/count.js"></script>
    <link rel="icon" href="_static/pymunk_favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="Benchmarks" href="benchmarks.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="advanced">
<h1>Advanced<a class="headerlink" href="#advanced" title="Link to this heading">¶</a></h1>
<p>In this section different “Advanced” topics are covered, things you normally
dont need to worry about when you use Pymunk but might be of interest if you
want a better understanding of Pymunk for example to extend it.</p>
<p>First off, Pymunk is a pythonic library built around the C-library
Chipmunk2D, which provides almost all of the base functionality around the
physics simulation such as collision detection, impulse solving etc.
Bascially it runs the simulation, and Pymunk calls it with input, and
receives the result.</p>
<p>To wrap Chipmunk Pymunk uses CFFI in API mode. On top of the CFFI wrapping is
a handmade pythonic layer to make it nice to use from Python code.</p>
<section id="impulse-solver-algorithm">
<h2>Impulse Solver Algorithm<a class="headerlink" href="#impulse-solver-algorithm" title="Link to this heading">¶</a></h2>
<p>Pymunk in itself only performs a minimum amount of physics calculation,
instead those are handled by the underlying C-library Chipmunk 2D. Chipmunk2D
(and therefor Pymunk) uses standard Euler to perform the integration</p>
<p>Scott/slembcke (the creator of Chipmunk2D), wrote this to describe the method
used on the
<a class="reference external" href="https://chipmunk-physics.net/forum/viewtopic.php?f=1&amp;t=1432&amp;p=6652&amp;hilit=euler#p6652">Chipmunk2D Forum</a>:</p>
<blockquote>
<div><p>Chipmunk works like this:</p>
<ol class="arabic simple">
<li><p>Integrate the positions of everything and finds colliding pairs.</p></li>
<li><p>Pre-calculate a number of properties of the contacts and joints.
(mass properties, bounce velocities, etc)</p></li>
<li><p>Integrate the velocities of everything.</p></li>
<li><p>Run a number of solver iterations, to fix velocity constraints.</p></li>
</ol>
<p>Case 1, a box sitting on the ground:</p>
<ol class="arabic simple">
<li><p>The box is at rest, it’s velocity is (very near) zero, it’s position
doesn’t change. Generate a contact with the ground.</p></li>
<li><p>Precalculate the contact properties, if elasticity is set, the
“bounce” velocity is calculated now (as 0).</p></li>
<li><p>Integrate the velocity, gravity makes the object accelerate downwards.</p></li>
<li><p>Solve the contact. Velocity should converge back to 0. If elasticity
was set, it will be handled correctly without resorting to threshold
velocities.</p></li>
</ol>
<p>#1 is really the most important part. If you were to update the
velocity before the postition, it would cause the box to move itself
into a position where it would intersect the ground. While Chipmunk has
to solve these overlaps anyway, avoiding them seems desirable. Another
very useful property is that when cpSpaceStep() returns, all of the
collision detection data structures are up to date. No need to reindex
them twice in a single frame if you want to make queries.</p>
</div></blockquote>
</section>
<section id="collision-detection-algorithm">
<h2>Collision Detection Algorithm<a class="headerlink" href="#collision-detection-algorithm" title="Link to this heading">¶</a></h2>
<p>Just as the impulse solver, the collision detection is also handled by the
underlying C-library Chipmunk2D.</p>
<p>Chipmunk uses GJK/EPA to find collisions between the tricky cases (e.g.
polygons, segment shapes). There is a blog post
<a class="reference external" href="http://howlingmoonsoftware.com/wordpress/enhanced-collision-algorithms-for-chipmunk-6-2/">here</a>
with more details.</p>
</section>
<section id="why-cffi">
<h2>Why CFFI?<a class="headerlink" href="#why-cffi" title="Link to this heading">¶</a></h2>
<p>This is a straight copy from the github issue tracking the CFFI upgrade.
<a class="reference external" href="https://github.com/viblo/pymunk/issues/99">https://github.com/viblo/pymunk/issues/99</a></p>
<p>CFFI have a number of advantages but also a downsides.</p>
<p>Advantages (compared to ctypes):</p>
<ul class="simple">
<li><p>Its an active project. The developers and users are active, there are new
releases being made and its possible to ask and get answers within a day on
the CFFI mailing list.</p></li>
<li><p>Its said to be the way forward for Pypy, with promise of better performance
compares to ctypes.</p></li>
<li><p>A little easier than ctypes to wrap things since you can just copy-paste the
c headers.</p></li>
</ul>
<p>Disadvatages (compared to ctypes):</p>
<ul class="simple">
<li><p>ctypes is part of the CPython standard library, CFFI is not. That means that
it will be more difficult to install Pymunk if it uses CFFI, since a
copy-paste install is no longer possible in an easy way.</p></li>
</ul>
<p>For me I see the 1st advantage as the main point. I have had great difficulties
with strange segfaults with 64bit pythons on windows, and also sometimes on
32bit python, and support for 64bit python on both windows and linux is
something I really want. Hopefully those problems will be easier to handle with
CFFI since it has an active community.</p>
<p>Then comes the 3rd advantage, that its a bit easier to wrap the c code. For
ctypes I have a automatic wrapping script that does most of the low level
wrapping, but its not supported, very difficult to set up (I only managed
inside a VM with linux) and quite annoying. CFFI would be a clear improvement.</p>
<p>For the disadvantage of ctypes I think it will be acceptable, even if not
ideal. Many python packages have to be installed in some way (like pygame),
and nowadays with pip its very easy to do. So I hope that it will be ok.</p>
<p>See the next section on why ctypes was used initially.</p>
</section>
<section id="why-ctypes-obsolete">
<h2>Why ctypes? (OBSOLETE)<a class="headerlink" href="#why-ctypes-obsolete" title="Link to this heading">¶</a></h2>
<p>The reasons for ctypes instead of [your favorite wrapping solution] can be
summarized as</p>
<ul class="simple">
<li><p>You only need to write pure python code when wrapping. This is good for
several reasons. I can not really code in c. Sure, I can read it and write
easy things, but Im not a good c coder. What I do know quite well is
python. I imagine that the same is true for most people using pymunk,
after all its a python library. :) Hopefully this means that users of
pymunk can look at how stuff is actually done very easily, and for example
add a missing chipmunk method/property on their own in their own code
without much problem, and without being required to compile/build anything.</p></li>
<li><p>ctypes is included in the standard library. Anyone with python has it
already, no dependencies on 3rd party libraries, and some guarantee that it
will stick around for a long time.</p></li>
<li><p>The only thing required to run pymunk is python and a c compiler (in those
cases a prebuilt version of chipmunk is not included). This should maximize
the multiplatformness of pymunk, only thing that would even better would
be a pure python library (which might be a bad idea for other reasons,
mainly speed).</p></li>
<li><p>Not much magic going on. Working with ctypes is quite straight forward.
Sure, pymunk uses a generator which is a bit of a pain, but at least its
possible to sidestep it if required, which Ive done in some cases. Ive also
got a share amount of problems when stuff didnt work as expected, but I
imagine it would have been even worse with other solutions. At least its
only the c library and python, and not some 3rd party in between.</p></li>
<li><p>Non api-breaking fixes in chipmunk doesnt affect pymunk. If a bugfix, some
optimization or whatever is done in chipmunk that doesnt affect the API,
then its enough with a recompile of chipmunk with the new code to benefit
from the fix. Easy for everyone.</p></li>
<li><p>Ctypes can run on other python implementations than cpython. Right now pypy
feels the most promising and it is be able to run ctypes just fine.</p></li>
</ul>
<p>As I see it, the main benefit another solution could give would be speed.
However, there are a couple of arguments why I dont find this as important as
the benefits of ctypes</p>
<ul>
<li><p>You are writing your game in python in the first place, if you really
required top performance than maybe rewrite the whole thing in c would be
better anyway? Or make a optimized binding to chipmunk.</p>
<p>For example, if you really need excellent performance then one possible
optimization would be to write the drawing code in c as well, and have that
interact with chipmunk directly. That way it can be made more performant
than any generic wrapping solution as it would skip the whole layer.</p>
</li>
<li><p>The bottleneck in a full game/application is somewhere else than in the
physics wrapping in many cases. If your game has AI, logic and so on in
python, then the wrapper overhead added by ctypes is not so bad in
comparison.</p></li>
<li><p>Pypy. ctypes on pypy has the potential to be very quick. However, right now
with pypy-1.9 the speed of pymunk is actually a bit slower on pypy than on
cpython. Hopefully this will improve in the future.</p></li>
</ul>
<p>Note that pymunk has been around since late 2007 which means not all
wrapping options that exist today did exist or was not stable/complete
enough for use by pymunk in the beginning. There are more options available
today, and using ctypes is not set in stone. If a better alternative comes
around then pymunk might switch given the improvements are big enough.</p>
</section>
<section id="code-layout">
<h2>Code Layout<a class="headerlink" href="#code-layout" title="Link to this heading">¶</a></h2>
<p>Most of Pymunk should be quite straight forward.</p>
<p>Except for the documented API Pymunk has a couple of interesting parts. Low
level bindings to Chipmunk, a custom documentation generation extension and a
customized setup.py file to allow compilation of Chipmunk.</p>
<dl class="simple">
<dt>docs/src/ext/autoexample.py</dt><dd><p>A Sphinx extension that scans a directory and extracts the toplevel
docstring. Used to autogenerate the examples documentation.</p>
</dd>
<dt>pymunk/_callbacks.py</dt><dd><p>Callbacks cannot be specified on a class, so they are all gathered here.</p>
</dd>
<dt>pymunk/_chipmunk_cffi.py</dt><dd><p>This file only contains a call to _cffi_backend .py, and exists mostly
as a wrapper to be able to switch between abi and api mode of Cffi. This
is currently not in use in the released code, but is used during
experimentation.</p>
</dd>
<dt>pymunk/pymunk_extension_build.py</dt><dd><p>The low level Chipmunk bindings are located in this file. Contains
configuration for how to build Chipmunk2D by Cffi into a pyd file.</p>
</dd>
<dt>setup.py</dt><dd><p>Except for the standard setup stuff this file also contain the custom
build commands to build Chipmunk from source, using a build_ext extension.</p>
</dd>
<dt>pymunk/examples/*</dt><dd><p>Collection of examples of usages of Pymunk. Tries to showcase most common
features of Pymunk.</p>
</dd>
<dt>pymunk/tests/*</dt><dd><p>Collection of (unit) tests. Does not cover all cases, but most core
things are there. The tests require a working chipmunk library file.</p>
</dd>
<dt>pymunk_cffi/*</dt><dd><p>Custom (c source and header) extensions to Chipmunk2D used by Pymunk.
Will be used when Cffi builds the pyd extension.</p>
</dd>
<dt>tools/*</dt><dd><p>Collection of helper scripts that can be used to various development tasks
such as generating documentation.</p>
</dd>
</dl>
</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h2>
<p>There are a number of unit tests included in the pymunk.tests package
(pymunk/tests). Not exactly all the code is tested, but most of it (at the time
of writing its about 85% of the core parts).</p>
<p>The tests can be run by calling the module</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">pymunk</span><span class="o">.</span><span class="n">tests</span>
</pre></div>
</div>
<p>Its possible to control which tests to run, by specifying a filtering
argument. The matching is as broad as possible, so <cite>UnitTest</cite> matches all the
unit tests, <cite>test_arbiter</cite> all tests in <cite>test_arbiter.py</cite> and
<cite>testResetitution</cite> matches the exact <cite>testRestitution</cite> test case</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">pymunk</span><span class="o">.</span><span class="n">tests</span> <span class="o">-</span><span class="n">f</span> <span class="n">testRestitution</span>
</pre></div>
</div>
<p>To see all options to the tests command use -h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">pymunk</span><span class="o">.</span><span class="n">tests</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<p>Since the tests cover even the optional parts, you either have to make sure
all the optional dependencies are installed, or filter out those tests.</p>
</section>
<section id="working-with-non-wrapped-parts-of-chipmunk">
<h2>Working with non-wrapped parts of Chipmunk<a class="headerlink" href="#working-with-non-wrapped-parts-of-chipmunk" title="Link to this heading">¶</a></h2>
<p>In case you need to use something that exist in Chipmunk but currently is not
included in pymunk the easiest method is to add it manually.</p>
<p>For example, lets assume that the is_sleeping property of a body was not
wrapped by pymunk. The Chipmunk method to get this property is named
cpBodyIsSleeping.</p>
<p>First we need to check if its included in the cdef definition in
pymunk_extension_build.py. If its not just add it.</p>
<blockquote>
<div><p><cite>cpBool cpBodyIsSleeping(const cpBody *body);</cite></p>
</div></blockquote>
<p>Then to make it easy to use we want to create a python method that looks nice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_sleeping</span><span class="p">(</span><span class="n">body</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">cpBodyIsSleeping</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">_body</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we are ready with the mapping and ready to use our new method.</p>
<p>Note that any cdef methods are not part of the public API, and as such might
change between minor or patch verisons of Pymunk.</p>
</section>
<section id="weak-references-and-free-methods">
<h2>Weak References and free Methods<a class="headerlink" href="#weak-references-and-free-methods" title="Link to this heading">¶</a></h2>
<p>Internally Pymunk allocates structs from Chipmunk (the c library). For example a
Body struct is created from inside the constructor method when a pymunk.Body is
created. Because of this its important that the corresponding c side memory is
deallocated properly when not needed anymore, usually when the Python side
object is garbage collected. Most Pymunk objects use <cite>ffi.gc</cite> with a custom
free function to do this. Note that the order of freeing is very important to
avoid errors.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/pymunk_logo_sphinx.png" alt="Logo"/>
            </a></p><div style="margin-left:10px;">
	<p>
		<iframe src="http://ghbtns.com/github-btn.html?user=viblo&repo=pymunk&type=watch&count=true&size=large" allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
	</p>
	<p>
		<a href="https://github.com/viblo/pymunk/actions/workflows/wheels.yml">
			<img src="https://github.com/viblo/pymunk/actions/workflows/wheels.yml/badge.svg" alt="Workflow status badge" loading="lazy" height="20">
	  	</a>
	</p>
</div>
<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="pymunk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="showcase.html">Showcase</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#impulse-solver-algorithm">Impulse Solver Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collision-detection-algorithm">Collision Detection Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-cffi">Why CFFI?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-ctypes-obsolete">Why ctypes? (OBSOLETE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-layout">Code Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tests">Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-non-wrapped-parts-of-chipmunk">Working with non-wrapped parts of Chipmunk</a></li>
<li class="toctree-l2"><a class="reference internal" href="#weak-references-and-free-methods">Weak References and free Methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.python.org/pypi/pymunk/">Downloads</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/viblo/pymunk/issues">Issue Tracker</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/viblo/pymunk">Source Repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="benchmarks.html" title="previous chapter">Benchmarks</a></li>
      <li>Next: <a href="changelog.html" title="next chapter">Changelog</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/advanced.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2013-2022, Victor Blomqvist.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/advanced.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>