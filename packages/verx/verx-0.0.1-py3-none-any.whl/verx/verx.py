# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_verx.ipynb.

# %% auto 0
__all__ = ['Verx']

# %% ../nbs/02_verx.ipynb 5
from typing import Iterable
from packaging.version import Version, InvalidVersion

# %% ../nbs/02_verx.ipynb 7
from atyp import StrQ, ModuleQ
from nlit import VERSION_INFO

# %% ../nbs/02_verx.ipynb 9
from .cons import (BLANK_VERSION, )

from verx.util import (
    getmodver, sysver, isverlike, ver2str
)

# %% ../nbs/02_verx.ipynb 11
class Verx(Version):
    @classmethod
    def frommod(cls, mod: ModuleQ = None, modname: StrQ = None, verattr: str = VERSION_INFO, default: tuple = BLANK_VERSION):
        return cls(ver2str(getmodver(mod, modname, verattr, default)))
    
    @classmethod
    def fromsys(cls, sys: ModuleQ = None) -> 'Verx': return cls(ver2str(sysver(sys)))
    
    @classmethod
    def fromstr(cls, s: str) -> 'Verx': return cls(s)
    
    def __init__(self, version: str = None):
        try: 
            super().__init__(ver2str(version or sysver()))
        except InvalidVersion:            
            super().__init__(ver2str(sysver()))

    @classmethod
    def to(cls, other) -> 'Verx': return other if isinstance(other, cls) else cls(other)
  
    def isoperable(self, other) -> bool: return isverlike(other)

    def __eq__(self, other) -> bool:
        return tuple(self) == tuple(self.to(other))

    def __lt__(self, other) -> bool:
        return tuple(self) <  tuple(self.to(other))
    
    def __le__(self, other)-> bool:
        return tuple(self) <= tuple(self.to(other))
    
    def __gt__(self, other) -> bool:
        return tuple(self) >  tuple(self.to(other))
    
    def __ge__(self, other) -> bool:
        return tuple(self) >= tuple(self.to(other))
        
    def __iter__(self) -> Iterable: return iter((self.major, self.minor, self.micro))
